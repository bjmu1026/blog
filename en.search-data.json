{"/blog/posts/archlinux_install/":{"data":{"":"制作启动u盘\n下载iso镜像文件\nsudo dd if=Downloads/archlinux-2025.10.01-x86_64.iso of=/dev/sda bs=8M 磁盘分区\nefi分区+linuxfilesystem分区\nmkfs.fat -F32 -n EFI /dev/nvme0n1p1 mkfs.btrfs -L myarch /dev/nvme0n1p2 mount /dev/nvme0n1p2 /mnt btrfs subvolume create /mnt/@ btrfs subvolume create /mnt/@home btrfs subvolume create /mnt/@log btrfs subvolume create /mnt/@cache lsblk umount /mnt 进入安装live\n确认是否uefi模式\nls /sys/firmware/efi/efivars 连接网络\niwctl device list station wlan0 scan station wlan0 get-networks station wlan0 connect wifi-name exit ping www.baidu.com 更新系统时钟\ntimedatectl set-ntp true timedatectl status 更换软件镜像源\nvim /etc/pacman.d/mirrorlist Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch vim /etc/pacman.conf ParallelDownloads = 20 #设置下载线程数 重新挂载硬盘\nmount -t btrfs -o ssd,compress=zstd,discard=async,noatime,nodiratime,subvol=@ /mnt mount -m -t btrfs -o ssd,compress=zstd,discard=async,noatime,nodiratime,subvol=@home /mnt/home mount -m -t btrfs -o ssd,compress=zstd,discard=async,noatime,nodiratime,subvol=@log /mnt/var/log mount -m -t btrfs -o ssd,compress=zstd,discard=async,noatime,nodiratime,subvol=@cache /mnt/var/cache mount -m /dev/nvm0n1p1 /mnt/boot/efi lsblk #查看 df -h #复查挂载情况 安装系统\npacman -S archlinux-keyring pacstrap /mnt base base-devel linux linux-firmware linux-headers btrfs-progs vim fish networkmanager intel-ucode sudo genfstab -U \u003e /mnt/etc/fstab cat /mnt/etc/fstab #检查 arch-chroot /mnt #切换到新系统 echo MyArch \u003e /etc/hostname #设置主机名 echo 127.0.1.1 myarch.localdomain myarch \u003e\u003e /etc/hosts ln -sf /usr/share/zoneinfo/Asia/Chongqing /etc/localtime #创建时区符号链接 hwclock --systohc #同步硬件时钟 vim /etc/locale.gen en_US.UTF-8 zh_CN.UTF-8 locale-gen #配置软件使用的语言，书写习惯和字符集 echo \"LANG=en_US.UTF-8\" \u003e /etc/locale.conf passwd root #更改root用户密码 useradd -m -G wheel new_user_name passwd new_user_name #添加新普通用户 pacman -S grub efibootmgr os-prober grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB_ARCH vim /etc/defaut/grub #配置grub GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=3 nowatchdog\" GRUB_DISABLE_OS_PROBER=false grub-mkconfig -o /boot/grub/grub.cfg exit #退回安装live umount -R /mnt reboot 进入新系统\n配置网络\nsystemctl enable --now NetworkManager ping www.baidu.com nmcli dev wifi list nmcli dev wifi connect \"SSID\" password \"password\" pacman -S fastfetch fastfetch #查看系统信息 vim /etc/sudoers #配置sudo %wheel ALL=(ALL:ALL) ALL %wheel ALL=(ALL:ALL) NOPASSWD:ALL 开启32bit库和archlinux中文社区仓库\nvim /etc/pacman.conf [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch [multilib] Include = /etc/pacman.d/mirrorlist pacman -Syyu pacman -S archlinuxcn-keyring pacman -S yay 安装桌面系统\npacman -S plasma-desktop sddm konsole dolphin systemctl enable sddm reboot #重启进入桌面 输入法\npacman -S fcitx5 fcitx5-chines-addons fcitx5-configtool vim /etc/profile export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export SDL_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx 启动蓝牙\nsudo systemctl enable --now bluetooth 音频系统\nsudo pacman -S pipewire pipewire-audio pipewire-pulse pipewire-alsa pipeware-jack sudo pacman -S xdg-desktop-portal-kde 显卡驱动\nsudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel intel-gpu-tools libva-utils libva-intel-driver 包管理器\nyay -S downgrade rm -rf .cache/yay/ #清理缓存 sudo pacman -Sc"},"title":"Archlinux_install"},"/blog/posts/awk/":{"data":{"":"","awk#awk":"语法 awk options `pattern {action}` file options -F \u003c分隔符\u003e 或 –field-separator=\u003c分隔符\u003e: 指定输入字段的分隔符，默认是空格，使用这个选项可以指定不同于默认分隔符的字段分隔符。 -v \u003c变量名\u003e=\u003c值\u003e ：设置awk内部变量的值，可以使用该选项将外部值传递给awk脚本中的变量 -f \u003c脚本文件\u003e 指定一个包含awk脚本的文件，这样可以在文件中编辑较大的awk脚本，然后通过-f选项将其加载。 -V 或–version 显示awk的版本信息 -h 或 –help 显示awk的帮助信息，包括选项和用法示例。 例子 awk '{print}' file #打印整行 awk '{print $1,$2}' file #打印特定列 awk -F ',' '{print $1,$2}' file #使用分隔符指定列 awk '{print NR,$1}' file #打印行数 awk '/pattern/{print NR,$0}' file #打印满足条件的行 awk '{sum += $1} END {print sum}' file #计算列的总和 awk 'max \u003c $1 {max = $1} END {print max}' file #打印最大值 awk '{printf \"%-10s %-10s\\n\",$1,$2}' file #格式化输出 基本用法 awk '{[pattern] action}' {filenames} awk '{print $1,$4}' log.txt #按空格或tab键分割，输出文件中的1,4项 awk '{printf \"%-8s %-10s\\n\",$1,$4}' log.txt #格式化输出1,4项 awk -F, '{print $1,$4}' log.txt #使用逗号进行分割 awk -F '[ ,:]' '{print $1,$2}' log.txt #使用多个分隔符，先使用空格再使用，再使用:进行分割 awk -v a=1 '{print $1,$1+a}' log.txt #设置变量 运算符 awk '$1\u003e2' log.txt"},"title":"Awk"},"/blog/posts/btrfs-arch-wiki/":{"data":{"":"创建文件系统 #单个设备系统 mkfs.btrfs -L label /dev/sda1 mkfs.btrfs -L label -n 32k /dev/sda #-n 元数据节点大小nodesie 默认16kb 最大64kb #多个设备系统 mkfs.btrfs -L label -d single -m raid1 /dev/sda1 /dev/sdb1 ... #raid0 raid1 raid10 single 写时复制CoW #禁用写时复制cow 空文件或目录中的新文件 chattr +C /path/dir_or_file #cp --reflink=auto / always / never #源文件 与 目标文件都具有或都不具有+C属性时，auto使用reflink,否则深拷贝，always使用reflink否则操作失败，never总是深拷贝 压缩 #支持的算法zlib lzo zstd lzo压缩级别1~9 zstd压缩级别-15~-1 1~15 #挂载compress=zstd:15/no/lzo:1/zlib #会检测数据的首个数据块压缩后大小是否减小，减小后续压缩，未减小整个文件标记为NOCOMPRESS后续都不压缩 #compress-force=zstd 则会检查每个数据块并决定是否压缩 #为现有文件启用压缩 #不会持久化，其他写入操作将应用原有的压缩设置 btrfs -v filesystem defragment -r -czstd -L1 / #持久化启用 chattr +c file btrfs property set file compression zstd 子卷 #btrfs子卷是可独立挂载的posix文件树 ，主要用途是快照 #创建子卷 btrfs subvolume create /path/subvolname btrfs subvolume create /mnt/@home #列出子卷 -t 表格视图 btrfs subvolume list -t /path #删除子卷 btrfs subvolume delete /path #挂载参数 noatime nodiratime ssd discard=async nodatacow compress=zstd commit=20 autodefrag"},"title":"btrfs-archlinux-wiki"},"/blog/posts/btrfs/":{"data":{"":"","btrfs#btrfs":"准备\n安装用户空间工具 btrfs-progs 创建文件系统\n单设备文件系统\nmkfs.btrfs -L 自定义标签 /dev/分区名 #默认元数据节点大小为16kiB，数据的默认扇区大小等于系统页大小（自动检测），-n选项指定节点大小nodesize mkfs.btrfs -L 自定义标签 -n 32k /dev/分区名#指定元数据节点大小为32kiB 多设备文件系统\n#-d 和 -m参数分别为数据和元数据配置RAID级别，默认情况下数据只有一份，元数据则镜像存储raid1 mkfs.btrfs -d single -m raid1 /dev/分区1 /dev/分区2 ... #必须在/etc/mkinitcpio.conf中加入udev、systemd或btrfs钩子之一才能使用多设备btrfs文件系统 profiles btrfs使用profiles这个概念来表示镜像、奇偶校验和条带属性，对应RAID术语中的RAID级别 配置文件系统\nCOW写时复制\n默认btrfs总是对所有文件使用cow,写入操作不会就地覆盖数据，而是将修改后的数据写入新位置，同时更新元数据指向新位置。\n禁用COW会禁用数据校验\n使用nodatacow选项挂载子卷只会影响新建的文件，而不会影响已存在的写时复制文件。\n#将目录中已存在的所有文件禁用写时复制 mv /path/to/dir /path/to/dir_old mkidr /path/to/dir chattr +C /path/to/dir cp -a --reflink=never /path/to/dir_old/ /paht/to/dir rm -rf /path/ro/dir_old nodatacow会禁用压缩和数据校验和\n#禁用空文件或目录中新文件的COW特性 chattr +C 目录或文件路径 对复制的影响 使用cp复制时，+C属性相当于在目标路径新建的文件，当原文件与目标文件都具有/不具有+C属性时，才能通过reflink进行复制 –reflink =auto 若原文件与目标文件都具有或不具有+C属性，则直接reflink，否则进行深拷贝 –reflink 或 –reflink=always 若原文件与目标文件都具有或不具有+C，则直接reflink，否则报错 –reflink=never 强制深拷贝 对快照的影响 快照会锁定原文件快位置，每一次快照后的第一次写入都会出发写时复制，可以把所有禁用写时复制的文件放在一个单独的子卷中冰面为该子卷创建快照 压缩\nbtrfs支持透明压缩，通常采用压缩算法越快性能越好。\n支持的压缩算法zlib\\lzo\\zstd，lzo无压缩级别，zlib 1-9 zstd 1-15 挂在指定压缩compress=算法[:级别]，btrfs会检测文件写入数据的首个数据块压缩后体积是否缩小，缩小会压缩本次写入的全部内容，否则被标记为nocompress,整个写入过程及该文件后续的所有写入过程都不会触发压缩 compress-force=算法[:级别] 会检查每次写入的每个数据块并分别决定是否压缩 为现有文件启用\n#不具有持久性，其他写入操纵将应用原有压缩设置 btrfs filesystem defragment -r -v -czstd #持久性启用对单个文件的压缩 chattr +C 文件 btrfs property set 文件 compression zstd 子卷\nbtrfs子卷是可独立挂载的POSIX文件树，而不是也不能被看作是块设备；btrfs不仅为整个卷提供了可挂载根，每个子卷也拥有独立的可挂载根 每个btrfs文件系统都有一个ID=5的顶层子卷，这个子卷不能被移除或被其他子卷替代。子卷可以在文件系统中移动，可以嵌套在任意其他子卷下，但子卷ID不变。 挂载文件系统时默认情况下挂载顶层子卷，除非更改默认子卷 #必须先挂载其上层子卷才能创建子卷 btrfs subvolume create 子卷父目录/子卷名称 #以@开头知识一个常见的命名约定 btrfs subvolume create /mnt/@sub #--parents 选项可以自动创建不存在的父目录 btrfs subvolume create /mnt/home/@userme #-t选项 表格视图查看路径所属文件系统的所有子卷列表 btrfs subvolume list -t path #删除子卷，确定在删除子卷前不要挂载该子卷，可能会导致文件系统不一致 btrfs subvolume delete 子卷路径 #挂载子卷 mount -o subvol=子卷path(相对于顶层子卷) /path #将顶层子卷作为/，可以简化子卷布局的更改 #更改默认子卷 btrfs subvolume set-default 子卷路径 #将路径所在的文件系统的默认子卷设置为ID为子卷ID的子卷 btrfs subvolume set-default 子卷ID 路径 配额\nquota group 在频繁创建大量快照的环境中，仍可以导致性能下降，特别是在删除快照时。 磁盘配额，传统unix配额通过限制用户拥有的所有文件总大小来控制空间使用。 btrfs采用基于子卷的配额组的机制，通过为用户创建独立子卷与配额组并限制配额组来实现。 #启用配额 btrfs quota enable 路径 #创建/销毁配额组 btrfs qgroup create 层级/ID 路径 #若存在子配额组，必须先解除关系 btrfs qgroup destory 层级/ID 路径 #分配/解除子配额组 btrfs qgroup assign 子配额组 父配额组 路径 btrfs qgroup remove 子配额组 父配额组 路径 #限制/取消限制配额组 #路径所在文件系统中限制配额组的总引用空间不超过1GB btrfs qgroup limit 1G 配额组 路径 # -e 独占引用空间 btrfs qgroup -e limie 20G 配额组 路径 #none 取消限制 btrfs qgroup limit none 配额组 路径 #列出配额组 #使用的是磁盘中的数据，可能需要sync后才能限制准确的统计数据 btrfs qgroup show 路径 # --sync 强制同步 btrfs qgroup --sync show 路径 总引用空间和独占引用空间\n总引用空间 所有能够从配额组内访问到的数据占用的存储空间 独占引用空间 只被配额组所属的子卷引用的数据所占用的存储空间 配额冲扫描\nquota rescn 能够都市圈文件系统的所有区段的元数据，据其更新各配额组的统计值 手动分配和接触分配子配额组时会自动触发配额重扫描，开销太大，无法等待重扫描结束后再返回，添加–no-rescan选项避免自动触发，后面手动触发 btrfs quota rescan 路径 提交间隔\n将数据写入文件系统的频率由btrfs本身和系统的设置决定，btrfs默认30s检查点间隔。可以在/etc/fstab 增加commit挂载参数来修改 LABEL=arch64 / btrfs defaults,noatime,compress=zstd,commit=120 0 0 简单配额\n将所有区段归属于首次分配它的子卷 btrfs quota -s enable 路径 固态硬盘TRIM\nbtrfs支持TRIM命令的SSD驱动器中释放未使用的块，挂载参数使用discard=async 使用\n交换文件\n创建交换文件 btrfs subvolume create /swap btrfs filesystem mkswapfile --size 4G --uuid clear /swap/swapfile swapon /swap/swapfile #/etc/fstab /swap/swapfile none swap defaults 0 0 显示使用和空闲空间\ndf这样的用户空间工具可能不会准确计算剩余空间\nbtrfs filesystem usage / btrfs fielsystem df / 碎片整理\n支持配置挂载参数autodefrag来实现在线的碎片整理 btrfs filesystem defragment -r / btrfs提供对RAID自修复冗余阵列和在线数据平衡\n检修scrub 能读取文件系统中的文件和元数据，并使用校验值和RAID存储上的景象区分三并修复损坏的数据 #手动启动一个后台文件系统的在线检查任务 btrfs scrub start / #检查该任务的运行状态 btrfs scrub status / 数据平衡balance 通过分配器再次传递文件系统中的所有数据，用于在添加或删除设备时跨设备重新平衡文件系统中的数据。 btrfs balance start --bg / btrfs balance status / 快照 是和其他子卷共享数据和元数据的简单子卷\n#source为要创建快照的对象，[dest/]name 快照安放的位置 btrfs subvolume snapshot source [dest/]name #-r 参数创建一个只读快照，为只读快照创建一个快照可以获得一个只读快照的可写入版本。 发送和接收\n#send发送一个快照,receive接收结束后会创建对应子卷 btrfs send /root_backup | btrfs receive /backup #--proto 2 --compressed-data 增加效率 btrfs send --proto 2 --compressed-data '/mnt/arch/snapshots/@var' | btrfs receive 'mnt/arch-v2/subvolumes/' #增量发送 btrfs send -p /root_backup /root_backup_new | btrfs receive /backup 调整大小\n#扩展到最大可用大小 btrfs filesystem resize max / #扩展到特定的大小 btrfs filesystem resize size / #指定增加或减少的大小 btrfs filesystem resize +size / btrfs filesystem resize -size / 提示和技巧\n无分区btrfs磁盘 mkfs.btrfs /dev/sdX mkfs.btrfs -f /dev/sdX 从EXT4转换 从安装cd启动，转化分区，修改/etc/fstab 并指定分区类型，最后一列fs_passno = 0 chroot到系统重建引导加载程序 #转化分区 btrfs-convert /dev/partition #删除备份子卷 btrfs subvolume delete /ext2_saved 引导进入快照 在grub-btrfs帮助下，在重新生成配置文件时用btrfs快照启动填充启动菜单"},"title":"btrfs"},"/blog/posts/compress/":{"data":{"":"","7-zip#7-zip":"支持多种压缩格式，并提供AES-256加密，分卷压缩等高级功能。 sudo pacman -S p7zip #压缩文件或目录 -a 添加文件到压缩包 -r 递归处理子目录 7z a archive.7z file1.txt fiel2.txt 7z a archive.7z my_dir/ -r #使用最高压缩率 7z a -mx=9 archive.7z large_file.iso #使用压缩算法 7z a -m0=lzma2 archive.7z large_file.iso #指定文件格式 7z a -tzip archive.zip my_dir/ 7z a -txz archive.tar.xz my_dir/ 7z a -tgzip archive.tar.gz my_dir/ #加密压缩 7z a -p archive.7z secret_files/ -r # 提示输入密码 7z a -pMyPassword archive.7z secret_files/ -r #直接使用指定密码 #分卷压缩 7z a -v500M archive.7z huge_file/ # l 查看压缩包的内容 7z l archive.7z # t 测试压缩包的完整性 7z t archive.7z # 删除压缩包内的文件 7z d archive.7z unwanted_file.txt # 更新压缩包 u 7z u archive.7z new_file.txt #解压缩 7z x archive.7z #解压到当前目录 7z x archive.7z -o /tmp/#解压到指定目录 7z x archive.7z -pMyPassword #解压加密文件 7z x -tzip archive.zip #指定文件格式","bzip2#bzip2":"基于Burrows-Wheeler算法的压缩工具，压缩率比gzip更高，但比xz稍低，适合中等大小的文件 #压缩文件,源文件被删除 bzip2 file.txt #保留原文件压缩 bzip2 -k file.txt #测试压缩文件的完整性 bzip2 -t file.txt.bz2 #-c输出到屏幕，-v显示详情 bzip2 -v -c file.txt \u003e file.txt.bz2 #解压缩 bzip2 -d file.txt.bz2 bunzip2 file.txt.bz2","gzip#gzip":"只能压缩单个文件，压缩速度快 #压缩文件，原文件被删除 gzip file.txt #压缩文件，原文件保留 gzip -k file.txt # -l 查看压缩文件信息 gzip -l file.txt.gz # -v 显示压缩/解压详情 gzip -v file.txt # -c 输出到标准输出 不修改原文件 gzip -c file.txt \u003e file.txt.gz # 批量压缩当前目录所有.txt文件 gzip *.txt #解压缩 gzip -v -d file.txt.gz gunzip -v file.txt.gz #gunzip是gzip -d 的别名","lz4#lz4":"是一个急速压缩和解压缩工具，特点是解压缩速度极快，但压缩率相对较低，适合用于需要快速压缩或解压缩的场景，如日志处理、实时数据传输。 #压缩文件 lz4 file.txt #调节压缩率 lz4 -9 file.txt #-9最高压缩率 #强制覆盖已有文件 lz4 -f file.txt #压缩后删除原文件 lz4 --rm file.txt #多线程压缩 lz4 -T0 file.txt #自动使用所有cpu核心 lz4 -T4 file.txt #使用4个线程 #检查压缩文件的完整性 lz4 -t file.txt.lz4 #解压缩 lz4 -d file.txt.lz4 unlz4 file.txt.lz4","rar#rar":"windows常用的压缩工具，linux需要安装unrar rar命令，支持rar格式，提供高压缩率、分卷压缩、密码保护和恢复记录等功能。 sudo pacman -S rar unrar #压缩文件或目录 a 添加文件到压缩包 rar a archive.rar file1.txt file2.txt rar a -r arhive.rar my_dir/ #-r 递归处理目录 #使用最高的压缩率-m5 rar a -m5 archive.rar large_file.iso #加密压缩 rar a -p archive.rar secret_files rar a -pMyPassword arvchive.rar secret_files #分卷压缩 rar a -v500M archive.rar huge_file #查看压缩包内容 unrar l archive.rar #解压文件 unrar x archive.rar #解压缩目录到当前目录 保留路径 unrar e archive.rar #解压缩到当前目录 不保留路径 unrar x archive.rar /target/path/ #解压缩到指定目录 #测试压缩包的完整性 unrar t archive.rar #删除压缩包内的文件 rar d archive.rar unwanted_file.txt #更新压缩包 添加新文件 rar u archive.rar new_file.txt","tar命令#tar命令":"#打包与解包 tar -cvf archive.tar my_dir/ tar -xvf archive.tar tar -xvf archive.tar -C /target/path/ #解包到指定目录 #查看归档内容 tar -tvf archive.tar.gz #排除特定文件 tar -cvf backup.tar --exclude=\"*.tmp\" --exclude=\"logs/\" my_dir/ #追加文件 tar -rvf archive.tar new_file.tar #压缩选项 tar -czvf archive.tar.gz tar -cjvf archive.tar.bz2 tar -cJvf archive.tar.xz tar --zstd -cvf archive.tar.zst tar --lz4 -cvf archive.tar.lz4 #增量备份 #首次完整备份 tar -czvf full_backup.tar.gz --listed-incremental=snapshot.file my_dir/ #后续增量备份 tar -czvf incr_backup.tar.gz --listed-incremental=snapshot.fiel my_dir/","xz#xz":"基于LZMA/LZMA2算法的高效压缩工具，压缩率通常比gzip bzip2更高，速度较慢，只能压缩单个文件 #压缩文件，原文件被删除 xz file.txt #压缩但保留原文件 xz -k file.txt # -l 查看压缩文件信息 xz -l file.txt.xz #使用最高压缩比 xz -9 large_file.iso # -Tn 多线程压缩 xz -T4 file.txt#4个线程加速 # -c 输出到屏幕，不生成文件 xz -c file.txt \u003e file.txt.xz #解压缩文件 xz -d file.txt.xz unxz file.txt.xz #unxz是xz -d的别名","zip#zip":"zip是linux下常用的压缩工具，支持创建、修改和提取zip格式的压缩文件。是一种跨平台的压缩格式，适用于windows和linux之间的文件交换。 #压缩文件 zip file.zip file # -r 压缩目录 zip -r dir.zip dir/ # -u 添加新文件或更新已有文件 zip -u file.zip file # -d 删除指定文件 zip -d file.zip file # -T 测试文件的完整性 zip -T file.zip # -e 加密zip文件（设置密码） zip -e file_en.zip file.zip # -x 排除一些文件 zip -r dir.zip /dir -x \"*.log\" \"*.tmp\" #解压缩到当前目录 unzip file.zip #解压缩到指定目录 unzip file.zip -d /path/to/dir","zstd#zstd":"一款fackbook开发的一款现代高性能压缩工具，在压缩速度、压缩率和内存占用之间取得了优秀平衡，适用于日志压缩、数据库备份、实时数据传输等场景。 #压缩文件 zstd file.txt #保留源文件 zstd -k file.txt #指定输出文件名 zstd -o archive.zst file.txt #调整压缩级别 -1 -19高压缩率 zstd -19 file.txt #多线程加速 zstd -T0 file.txt #使用所有的cpu核心 zstd -T4 file.txt #使用4个线程 #查看压缩信息 zstd -l archive.zst #解压缩 zstd -d file.txt.zst unzstd file.txt.zst #unsztd 是zstd -d 的别名 #管道压缩/解压缩 cat file.txt | zstd \u003e file.txt.zst cat file.txt.zst | zstd -d \u003e file.txt"},"title":"Compress"},"/blog/posts/font/":{"data":{"":"","fonts-in-linux#Fonts in linux":"linux当中，字体是由fontconfig来统一管理的，它是由Free Desktop推出的字体管理工具，通用语各大发行版本，甚至在Windows下也能使用。 linux字体目录在/usr/share/fonts/目录下，或者用户字体目录~/.fonts/。 使用archlinux 需要手动安装中文字体，否则在显示中文的地方，智能看到一片空白或者乱码，如果漏掉英文字体，且系统默认语言为英文，那就只能看到白茫茫一片。 安装对应发行版的noto字体包，可以解决最基本的文字显示问题。 #archlinux noto-fonts为西文字体，noto-fonts-cjk为中日韩字体 sudo pacman -S noto-fonts noto-fonts-cjk 为了便于管理，将字体文件放到字体文件夹的二级目录里，例如/usr/share/fonts/TTF\n正确设置区域，解决字体显示混乱的问题\nlinux系统的区域(locale)设置，直接决定了系统显示的语言、时间格式、数字格式等体验。\n#/etc/locale.gen #en_US.UTF-8 UTF-8 #zh_CN.UTF-8 UTF-8 sudo locale-gen 安装windows字体\n直接进入windows的字体目录c:\\Windows\\Fonts\\选中需要的字体，复制到linux /usr/share/fonts/Windows_TTF目录下\nsudo mkdir /usr/share/fonts/Windows_TTF/ sudo cp *.TTF *.ttf *.otf /usr/share/fonts/Windows_TTF/ #刷新字体缓存，使更改生效 fc-cache -fv"},"title":"Font"},"/blog/posts/git/":{"data":{"":"","git安装#git安装":"git clone https://github.com/git/git sudo pacman -S git","仓库创建#仓库创建":"使用git init 创建 git的很多命令都需要在git的仓库中运行，所以git init是使用git的第一个命令。执行完git init会生成一个.git目录，该目录包含了资源的所有元数据，其他的项目目录保持不便。 #创建一个目录 mkdir my-project cd my-project #会使用当前目录作为git仓库，我们只需要使之初始化 git init #使用指定目录作为git仓库，初始化后会在newrepo目录下出现一个名为.git的目录 git init newrepo 使用git clone创建 使用git clone从现有的git仓库中拷贝项目 #克隆仓库，使用仓库名称作为目录名称 git clone #克隆到指定的目录中 git clone","分支管理#分支管理":"查看分支 #查看本地所有分支 git branch #查看远程仓库所有分支 git branch -r #查看本地和远程仓库的所有分支 git branch -a 创建分支 #创建新分支并切换到新分支去 git checkout -b #切换分支 git checkout 合并分支 #合并分支 git merge #切换到分支main,并且合并feature-xyz分支 git checkout main git merge feature-xyz 解决合并冲突 #当合并遇到冲突，git会标记冲突文件，你需要手动解决冲突，打开冲突文件，按标记解决冲突。解决完成后提交 git add git commit 删除分支 #删除本地分支 git branch -d #强行删除为合并的分支 git branch -D #删除远程分支 git push origin --delete","基本概念#基本概念":"","工作区#工作区":"工作区 就是你在电脑里能看到的目录 暂存区 一般存放在.git目录下的index文件中，所以我们把暂存区有时也叫做索引 版本库 工作区有一个隐藏目录.git,这个不算工作区，而是git的版本库 # 暂存区的目录树会被重写，被main分支指向的目录树所替换，但是工作区不受影响 git reset HEAD # 删除暂存区的文件，工作区不受改变 git rm --cached # 会用暂存区中全部文件替换工作区的文件 git checkout . #回用暂存区中的指定文件替换工作区中的文件 git checkout -- #会使用HEAD指向的main分支中的全部文件替换暂存区以及工作区中的文件 git checkout HEAD . #张使用HEAD指向的main分支中的指定文件替换暂存区以及工作区中的文件 git cheacout HEAD 选择性的将工作区中的文件修改添加到暂存区中 git add filename //将单个文件添加到暂存区中 git add .\t//将工作区中的所有文件添加到暂存区中 git status //查看那些文件在暂存区中 版本库包含项目的所有版本历史快照 git commit -m \"Commit message\" //将暂存区中的更改提交到本地版本库 git log //查看提交历史 git diff //查看工作区的暂存区之间的差异 git diff --cached //查看暂存区和最后一次提交的差异 将本地版本库提交推送到远程仓库 git push origin branch-name 从远程仓库获取更新 git pull origin branch-name #或者 git fetch orgin branch-name git merge origin/branch-name","工作流程#工作流程":"#克隆仓库，参与一个已有的项目，首先需要将远程仓库克隆到本地 git clone https://github.com/username/repo.git cd repo #创建新分支，为了避免直接在main或master分支上进行开发，通常会城建一个新的分支 git checkout -b new-feature #在工作目录中进行代码编辑，一边进行下一步的提交操作 git add filename //添加一个文件 git add . //添加目录下的所有文件 # 提交更改，将暂存区的更改提交到本地仓库，并添加提交信息 git commit -m \"Add new feature\" #拉取最新更改，在推送本地更改之前，最好从远程仓库拉去最新更改，以避免冲突 git pull origin main #推送更改，将本地的提交推送到远程仓库 git push origin new-feature #在PR审核后，可以将远程仓库的主分支合并到本地分支 git checkout main git pull origin main git merge new-feature #如果不再需要新功能分支，可以将其删除 git branch -d new-feature #或者可以从远程仓库中删除分支 git push origin --delete new-feature","远程仓库#远程仓库":"#添加远程仓库 git remote add [shortname] [url] git remote add origin git@github.com:yourname/reponame.git #生成rsa密钥对，用于和github仓库进行ssh连接 #生成的~/.ssh/id_rsa.pub公钥复制到github用户设置里面的ssh\u0026gpg keys里面 ssh-keygen -t rsa -C \"youremail@example.com\" #测试连接 ssh -T git@github.com #创建一个远程仓库 #在github上创建一个仓库并将REAMDME.md文件推送到远程仓库 mkdir git-test-repo cd git-test-repo echo \"Git test repo testing\" \u003e\u003e README.md git init git add README.md git commit -m \"add README.md file\" git remote add origin git@github.com:yourname/repo-name.git git push -u origin main #查看远程仓库 git remote //查看当前配置有哪些远程仓库 git remote -v //可以看到每个别名的实际链接地址 #拉取远程仓库 git fetch git merge #或者 git pull #删除远程仓库 git remote rm [别名] git remote rm origin","配置#配置":"#使用--global所有的项目都会使用这里配置的用户信息，保存在用户主目录下 #不使用--global,保存在.git/config文件中 git config --global user.name \"yourname\" git config --global user.email \"test@example.com\" git config --global core.editor \"vim\" #可以查看配置的信息 git config --list #可以直接修改配置文件 vim /etc/gitconfig vim .gitconfig #用于生成rsa密钥 ssh-keygen -t rsa -b 4096 -C \"youremail@example.com\""},"title":"Git"},"/blog/posts/grub-btrfs/":{"data":{"":"","grub-btrfs#grub-btrfs":"grub-btrfs是一个增强版的GRUB引导加载器，它能够自动检测并列出btrfs分区上的所有快照，包括手动创建以及由snapper或timeshift工具生成的快照。 能智能地发现/boot分区是否独立，并自动识别内核、initramfs和intel/amd微码。 提供了一个systemd服务，可以自动化更新grub.cfg文件 sudo pacman -S grub-btrfs #在文件/etc/default/grub-btrfs/config中启用快照扫描 GRUB_BTRFS_OVERRIDE_BOOT_PARTITION_DETECTION=\"true\" #更新GRUB配置 sudo grub-mkconfig -o /boot/grub/grub.cfg grub-btrfsd\n自动更新grub.cfg文件 #sudo vim /usr/lib/systemd/system/grub-btrfsd.service #ExecStart=/usr/bin/grub-btrfsd --syslog --timeshift-auto #配合timeshift的快照 sudo pacman -S inotify-tools #安装依赖 sudo systemctl daemon-reload sudo systemctl enable grub-btrfsd sudo systemctl start grub-btrfsd"},"title":"Grub Btrfs"},"/blog/posts/grub/":{"data":{"":"","grub#GRUB":"GRUB(Grand Unified Bootloader)大统一加载器，是一个引导加载程序，当前为GRUB2。原始的GRUB被称为GRUB Legacy。\ngrub捆绑了由自己支持的多种文件系统，btrfs、ext4、FAT32、XFS。 使用一个单独的/boot分区，可以规避大部分不兼容问题。 UEFI\n使用UEFI安装时，一定要让安装介质以UEFI启动，否则efibootmgr无法添加GRUB UEFI启动项。\n要从一个磁盘上使用UEFI启动，必须有一个efi分区。 GRUB能够通过insmod加载额外模块，这时候UEFI无法使用安全启动Secure Boot。 使用了安全启动，要使用grub额外模块，必须通过grub-mkstandalone、grub-install重新安装GRUB，以生成包含所需模块的grubx64.efi 安装\n安装grub 、efibootmgr包，efibootmgr用于grub脚本用来将启动项写入NVROM。\n挂载efi系统分区：选择一个启动引导器标识例如ARCH、GRUB等，将在esp/EFI/中创建一个与标识同名的目录来存储EFI二进制文件。而且这个名字还会用于UEFI启动菜单中区分GRUB启动项。\n执行下面命令将GRUB EFI应用grubx64.efi安装到esp/EFI/GRUB/，并将其模块安装到/boot/grub/x86_64-efi/\n#需要在chroot之后再运行grub-install #否则需要使用--boot-directory=选项来制定挂载/boot目录的路径，如--boot-directory=/mnt/boot grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB #如果固件启动器数量已满，这个命令会失败，需要使用efibootmgr删除不必要的条目 如果使用–removable选项，那GRUB将会被安装到esp/EFI/BOOT/BOOTX64.EFI，此时即使EFI变量被重设或这你把这个驱动器连接到其他电脑上，你仍可以从这个驱动器上启动。\n启用安全启动\nGRUB支持CA密钥或者shim进行安全启动。\nCA\ngrub-intall --target=x86_64-efi --efi-directory=sep --bootloader-id=GRUB --modules=\"tpm\" --disabel-shim-lock Shim-lock\n当使用shim-lock时，只有GRUB二进制文件包含了全部用于读取含有vmlinuxz和initramfs镜像的文件系统的必要模块时，才可以成功进入安全启动模式。\n安全启动模式下，不允许使用insmod加载模块。\n根据ubuntu的官方构建脚本，整合下列模块\n基础模块\nall_video,boot,btrfs,cat,chain,configfile,echo,efifwsetup,efinet,ext2,fat,font,gettext,gfxmenu,gfxterm,gfxterm_background,gzio,halt,help,hfsplus,iso9660,jpeg,keystatus,loadenv，loopback,linux,ls,lsefi,lsefimmap，lsefisystab,lssal,memdisk,mincmd,normal,ntfs,part_apple,part_msdos,part_gpt,password_pbkdf2,png,probe,reboot,regexp,search,search_fs_uuid,search_fs_file,search_label,sleep,smbios,squash4,test,true,video,xfs,zfs,zfscrypt,zfsinfo 平台特定模块\nplay 启动时播放声音 cpuid 启动时检查cpu功能 tpm 提供可度量启动，可信平台模块支持 高级模块\ncryptodisk 从dm-crypt加密磁盘启动 gcry_algorithm 支持特定散列和加密算法 luks 从LUKS加密的磁盘启动 ic|lvm 从LVM逻辑卷启动 mdraid09\\mdraid1x,raid5rec,raid6rec 从raid虚拟磁盘启动 grub从UEFI shim加载器启动，还需要一个secure boot advanced targeting SBAT文件/部分包含在efi二进制文件中。在/usr/share/grub/sbat.csv提供了一个简单的SBAT.csv文件。\ngrub-install --target=x86_64-efi --efi-directory=sep --modules=${GRUB_MODULES} --sbat /usr/share/grub/sbat.csv sbsign --key MOK.key --cert MOK.cert --output esp/EFI/GRUB/grubx64.efi esp/EFI/grubx64.efi cp esp/EFI/GRUB/grubx64.efi esp/EFI/BOOT/grubx64.efi 配置\nGRUB每次启动的时候加载配置文件/boot/grub/grub.cfg\n每当修改/etc/default/grub 或者 /etc/grub.d/中的文件后，都需要再次生成主配置文件\ngrub-mkconfig -o /boot/grub/grub.cfg 自动生成脚本默认将在生成的配置文件中为所有已安装的arch linux 内核添加条目。每次安装内核后都需要重新运行一次grub-mkconfig\n探测其他操作系统\n安装os-prober并挂载包含其他系统引导程序的磁盘分区，然后重新运行grub-mkconfig 输出Warning: os-prober will not be executed to detect other bootable partitions 需要编辑/etc/default/grub取消 GRUB_DISABLE_OS_PROBER=false注释 windows 以UEFI安装的windows需要确保含有windows boot manager(bootmgfw.eft)的分区被挂载，以root身份运行os-prober来检测并为其生成启动菜单。 可能需要安装fuse3，并使用ntfs-3g挂载分区 额外参数\n/etc/default/grub中摄这GRUB_CMDLINE_LINUX和GRUB_CMDLINE_LINXU_DEFAULT变量，生成普通启动项时，这两个参数的值会合并在一起传给内核。生成recovery启动项时，仅使用GRUB_CMDLINE_LINUX参数。 支持系统休眠后恢复 GRUB_CMDLINE_LINUX_DEFAULT=“resume=UUID=uuid-of-swap-partition quiet” 设置启动菜单的顶层启动项\n/etc/default/grub中指定GRUB_TOP_LEVEL=内核路径 LVM\n如果你的/boot或者/使用了LVM确保lvm模块已经预先加载好\n/etc/default/grub GRUB_PRELOAD_MODULES=\"... lvm\" RAID\n需要加载GRUB模块mdraid09 或者 mdraid1x\n/etc/default/grub GRUB_PRELOAD_MODULES=\"... mdraid09 mdraid1x\" #/dev/md0写成 set root=(md/0) #/dev/md0p1写成 set root=(md/0,1) 如果在/boot分区使用raid1时安装grub\ngrub-install --target=i386-pc --debug /dev/sda grub-install --target=i386-pc --debug /dev/sdb 定制grub.cfg\n基础的GRUB配置如下的设置\n(hdX,Y) 为磁盘x上的y分区，分区编号从1开始，磁盘编号从0开始 set default=N 用户没有进行选择时的默认启动项 set timeout=M 使用默认启动项之前等待用户自动选择的时间 menuentry “title” {entry options} 为一个标题为title的启动条目 set root=(hdX,Y) 设置/boot分区，即内核和GRUB模块存储的位置 LoaderDevicePartUUID\ngpt分区自动挂载使用的systemd-gpt-auto-generator需要LoaderDevicePartUUID UEFI变量以正常工作\n#/boot/grub/grub.cfg if [ \"$grub_platform\" = \"efi\"];then insmod bli fi grub启动菜单条目示例\nmenuentry \"System shutdown\" { echo \"System shutting down...\" halt } menuentry \"System restart\" { echo \"System rebooting...\" reboot } if [ ${grub_platform} == \"efi\" ];then #放入仅grub处于uefi模式的时候显示的条目 menuentry \"UEFI Firmware Settings\" --id 'uefi-firmware'{ fwsetup } fi menuentry \"UEFI Shell\" { insmod fat insmod chain search --no-floppy --set=root --file /shellx64.efi chainloader /shellx64.efi } menuentry \"Arch Linux\"{ insmod fat insmod chain search --no-floppy --set=root --fs-uuid FILESYSTEM_UUID chainloader /EFI/Linux/arch-linux.efi } menuentry \"Other Linux\"{ set root=(hd0,2) linux /boot/vmlinuz initrd /boot/initrd.img } menuentry \"Other Linux\" { search --no-floppy --set=root --fs-uuid uuid #search -no-floppy --set=root --label OTHER_LINUX linux /boot/vmlinuz initrd /boot/initrd.img } menuentry \"configfile hd0,gpt4\" { insmod part_gpt insmod btrfs insmod ext2 set root='hd0,gpt4' configfile /boot/grub/grub.cfg } #uefi/gpt模式下安装windows if [ '${grub_platfome}' == \"efi\" ];then menuentry \"MS Windows UEFI/GPT\" { insmod part_gpt insmod fat insmod chain #grub-probe --target=fs_uuid esp/EFI/Microsoft/Boot/bootmgfw.efi得到 $fs_uuid #grub-probe --target=hints_string eps/EFI/Microsoft/Boot/bootmgfw.efi #--hint-bios=hd0,gpt1 --hint-efi=hd0,gpt1 --hin-baremetal=ahci0,gpt1 search --no-floppy --fs-uuid --set=root $hints_string $fs_uuid chainloader /EFI/Microsoft/Boot/bootmgfw.efi } fi grub命令行\nGRUB的主要功能通过/boot/grub里的模块实现，按需加载。GRUB提供了gurb\u003e正常的shell以及grub rescue\u003e救急shell。 grub rescue\u003e set prefix=(hdx,y)/boot/grub grub rescue\u003e insmod (hdx,y)/boot/grub/i386-pc/normal.mod rescue:grub\u003enormal 支持对长输出进行分页\ngrub\u003e set pager 1 使用命令行引导操作系统\n使用chainloading来引导存储在一个驱动器或者分区中的windows或者linux系统 chainloading的意思是用当前的启动加载器去加载另一个启动加载器，也叫做链式加载 要被加载的另一个启动加载器可能在一个有分区表的磁盘的头部MBR，或者在一个未分区磁盘或者一个分区的头部VBR，也可能在使用UEFI得情况下是一个EFI可执行文件 #分区的VBR set root=(hdx,y) chainloader +1 boot #MBR或者未分区的VBR set root=hdX chainloader +1 boot #uefi insmod fat set root=(hdx,gpty) chainloader (${root}/EFI/Microsoft/Boot/bootmgfw.efi) boot 急救模式 #grub rescue\u003e set prefix=(hdx,y)/boot/grub insmod linux #启动熟悉的linux和initrd命令的支持 set root=(hdx,y) linux /boot/vmlinuz-linux root=/dev/sdaz initrd /boot/initramfs-linux.img boot 移除GRUB\n#运行efibootmgr确保安装了其他启动加载器并配置其接管启动引导工作 efibootmgr #BootOrder: 0003, 0001, 0000, 0002 #Boot0000* Windows Boot Manager HD(2,GPT,uuid)/File(\\EFI\\Microsoft\\Boot\\bootmgfw.efi) #Boot0001* GRUB HD(2,GPT,uuid)/File(/EFI/GRUB/grubx64.efi) ... efibootmgr --delete-bootnum -b 1 #再删除esp/EFI/grub和/boot/grub目录"},"title":"Grub"},"/blog/posts/hexdump/":{"data":{"":"","linux-查看十六进制格式的文件#linux 查看十六进制格式的文件":"#以规范的十六进制和ASCII格式显示文件内容 hexdump -C filename #可以生成十六进制转储，也可以将十六进制转储回二进制 xxd filename xxd -l 256 filename # 查看前256字节 xxd -p filename # 以连续格式查看 # 指定以十六进制单字节格式显示 od -t x1 filename"},"title":"Hexdump"},"/blog/posts/mysql/":{"data":{"":"mysql","mysql#mysql":"","安装#安装":"#安装mysql sudo pacman -S mysql #初始化mysql sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql #使用生成的随机密码登陆 mysql -u root -p\"[passwd]\" #修改root密码 mysql\u003e alter user 'root'@'localhost' identified by \"newpasswd\";","用户管理#用户管理":"#创建用户 CREATE USER 'USERNAME'@\"HOST\" IDENTIFIED BY 'PASSWD'; #授权 privileges 包括all privileges, select, insert, update, delete等 #database_name.* 对某个数据库的所有表授权， database_name.table_name可以指定表进行授权。 GRANT privileges ON database_name.* TO 'username'@'host'; #刷新授权 FLUSH PRIVILEGES; #查看用户的权限 SHOW GRANTS FOR \"username\"@\"host\"; #撤销权限 REVOKE privileges ON database_name.* FROM 'username'@'host'; #删除用户 DROP USER 'username'@'host'; #修改用户主机 DROP USER 'username'@'host'; CREATE USER 'username'@'another_host' identified by 'passwd';","配置文件#配置文件":"/etc/my.cnf\n基本设置 basedir mysql服务器的基本安装目录 datadir 存贮mysql数据文件的位置 socket mysql服务器unix套接字文件的地方 pid-file 存储当前运行的mysql进程id的文件路径 port 服务器监听的端口 服务器选项 bind-address 制定mysql服务器监听的ip地址 server-id 在复制配置中，为每个mysql服务器设置的唯一标志符。 default-storage-eng"},"title":"Mysql"},"/blog/posts/nasm/":{"data":{"":"","nasm编译器#nasm编译器":"开源的汇编语言编译器 # -f 指定编译的文件格式 nasm -f elf myfile.asm #将myfile.asm编译成ELF格式的文件myfile.o nasm -f bin myfile.asm #将myfile.asm编译成纯二进制格式的文件myfile.com nasm -f coff myfile.asm -l myfile.lst #以十六进制代码的形式产生列表文件输出，并让代码显示在左侧 使用 -l 选项并给出列表文件名 # -o 制定编译后的文件名称 nasm -f bin program.asm -o program.com nasm -f bin driver.asm -o driver.sys # -On 指定多遍优化 nasm -f elf -O0 myfile.asm -o program.o nasm -f elf -O1 myfile.asm -o program.o nasm -f elf -On myfile.asm -o program.o # -i 包含文件搜索路径 nasm -i ./macrolib -f obj myfile.asm #在源文件中看到%include操作符的时候，不仅仅在当面目录下搜索给出的文件，还会搜索-i选项在命令行中制定的所有路径 # -p 预包含一个文件 nasm myfile.asm -p myinc.inc #和在头文件中写%include \"myinc.inc\"然后运行nasm myfile.asm的结果是一样的 # -d 预定义一个宏 nasm myfile.asm -dFOO=1000 #与在源文件中写%define FOO 1000的效果是一样的 # -u 取消一个宏定义 nasm myfile.asm -dFOO=100 -uFOO #取消FOO宏定义"},"title":"Nasm"},"/blog/posts/rsync/":{"data":{"":"remote sync 远程同步\n与FTP或scp不同的是，rsync会检查发送方和接收方已有的文件，仅传输有变动的部分(默认使用文件大小和修改时间决定文件是否需要更新)。 安装\nsudo pacman -S rsync 基本用法\nrsync -r source destination #r表示递归，必须要此参数，否则rsync启动不成功 rsync -r source1 source2 destination #source1 source2都会被同步到destination rsync -a source destination #a除了可以同步以外，还可以同步元信息，比如修改时间，权限等 rsync -anv sour/ destination #-n --dry-run模拟执行的结果 rsync -av --delete source/ destination #将删除只存在于目标目录，不存在于源目录的文件 #--exclude 排除文件 rsync -av --exclude='*.txt' source/ destination rsync -av --exclude='.*' source/ destination rsync -av --exclude='file1.txt' --exclude='dir1/*' source/ destination rsync -av --exclude={'file1.txt'.'dir1/*'} source destination rsync -av --exclude='exclude-file.txt' source/ destination #--include 指定必须同步的文件模式 rsync -av --include='*.txt' --exclude='*' source/ destination #ssh协议 rsync -av source/ username@remote_host:destination rsync -av username@remote_host:source/ destination #若ssh有附加参数 rsync -av --progress -e 'ssh -p 2244' source/ user@remote_host:destination #rsync协议 #如果另一台服务器安装了rsync守护程序 rsync -av source/ 192.168.10.254::module/destination #module是rsync守护程序制定的一个资源名，有管理元分配， #rsync rsync://192.168.10.254 可以查看rsync守护程序所有的module列表 #增量备份 rsync -av --progress --delete --link-dest /compare/path /source/path /target/path #--link-dest 指定基准目录compare/path，源目录和基准目录比较，找出变动的文件，将他们拷贝到目标目录/target/path中，那些没变动的目录会生成硬链接。 #这个命令第一次是全量备份，后面对是增量备份"},"title":"Rsync"},"/blog/posts/rust/":{"data":{"":"安装rust #安装rustup命令 curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh #升级rust rustup update #卸载rust rustup self uninstall #所有的工具都安装在~/.cargo/bin目录下的 export PATH=$PATH:~/.cargo/bin #手动添加工具目录至PATH路径 source ~/.cargo/env.fish 使用国内的crateio 镜像 ~/.cargo/config.toml\n[source.crates-io] registry = \"https://github.com/rust-lang/crates.io-index\" replace-with = \"tuna\" [source.tuna] registry = \"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index/\"","使用国内的crateio-镜像#使用国内的crateio 镜像":"","安装rust#安装rust":""},"title":"Rust"},"/blog/posts/sed/":{"data":{"":"","sed-流编辑器#sed 流编辑器":"非交互式的对内容进行增删查改的操作，只能在命令行输入编辑命令、指定文件名，然后在屏幕上查看输出。编辑对象为文件中的行 文件的内容增加操作 sed 'a\\append data \"haha\"' data1 #在data1的每行后面追加一行新数据内容append data \"haha\" sed '2a\\append data \"haha\"' data1 #在data1的第二行后面追加一行新数据内容append data \"haha\" sed '2,4a\\append data \"haha\"' data1 #在data1的第二到四行后面追加一行新数据内容append data \"haha\" sed '/3 the/a\\append data \"haha\"' data1 #启用字符串匹配，匹配“3 the”的行后面追加一行新数据内容append data “haha\" sed 'i\\insert data' data1 #在每行的前面插入一行新数据insert data sed '2i\\insert data' data1 sed '2,4i\\insert data \"haha\"' data1 sed '/3 the/i\\insert data \"haha\"' data1 文件内容替换操作 echo \"this is a test\" | sed 's/test/text/' #将test修改为text sed 's/dog/cat/' data1 #将每一行中的dog替换为cat sed '2s/dog/cat/' data1 sed '2,4s/dog/cat/' data1 sed '/3 the/s/dog/cat/' data1 文件内容更改操作 sed 'c\\change data \"haha\"' data1 #将每一行更改为change data \"haha\" sed '2c\\change data \"haha\"' data1 sed '2,4\\change data \"haha\"' data1 sed '/3 the/c\\change data \"hahah\"' data1 字符转换，将匹配的内容转换为新的数据 sed 'y/abc/ABC/' data1 #将每一行中的a b c字符对应转换为A B C字符 文件内容删除 sed 'd' data1 #删除文件data1中的所有数据 sed '3d' data1 sed '2,4d' data1 sed '/3 the/d' data1 将文件内容输出到屏幕 sed 'p' data1 #打印文件data1到屏幕上 sed '3p' data1 #打印文件的第三行内容 sed '2,4p' data1 sed '/3 the/p' data1 在命令行中使用多个命令-e参数 sed - e 's/brown/green/;s/dog/cat/' data1 从文件读取编辑器命令-f file vim abc s/brown/green/ s/dog/cat/ s/fox/elephant/ sed -f abc data1 #等效为 sed -e 's/brown/green/;s/dog/cat/;s/fox/elephant/' data1 一直内存输出 sed -n '2,$p' data1 #打印文件第二行到最后一行的内容 使用正则表达式 sed -n -r '/^(3 the)/p' data1 标志 sed 's/dog/cat/2' data2 #替换第二行dog为cat sed 's/dog/cat/g' data2 #将data2从所有的dog替换为cat sed '3s/dog/cat/p' data2 #将第三行的dog替换为cat并打印 sed '3s/dog/cat/w text' data2 #将第三行中的dog替换为cat并存入文件text中"},"title":"Sed"},"/blog/posts/split/":{"data":{"":"split 用于分割文件的命令，可以将大文件拆分为多个小文件，常用于分卷压缩、日志切割或网络传输。 #按文件大小分割文件 split -b 100M large_file.iso split_file_ #生成文件split_file_aa split_file_ab ... split -b 500M -d -a 2 big_data.bin data_part_.part #生成文data_part_00.part #按行数分割文件 split -l 1000 access.log split_log_ #合并分割文件 cat split_file_* \u003e merged_file.iso cat data_part_*.part \u003e restored_data.bin #结合tar分卷压缩 tar -czvf - my_dir/ | split -b 500m - backup.tar.gz. cat bacup.tar.gz.* | tar -xzvf -"},"title":"Split"},"/blog/posts/sqlite/":{"data":{"":"","sqlite3-db#sqlite3 db":"sqlite3 命令 .help #获取可用命令的清单 .show #显示当前各种设置的值 .timeout MS #尝试打开锁定的表的时间 .timer on/off #开启或关闭cpu定时器 .width NUM NUM #为column 模式设置列宽度 .mode MODE # csv,column,html,line,list,tabs,tcl .stats on|off #开启或关闭统计 .header on/off #开启或关闭头部显示 .echo on/off #开启或关闭echo命令 .tables #列出表的名称 .databases #列出数据库的名称极其所依附的文件 .quit #退出sqlite提示符 .exit #退出sqlite提示符 .schema sqlite_master #主表中保存数据库的关键信息，并把它命名为sqlite_master SQLITE 数据类型 NULL //Null值 INTEGER\t//有符号整数 REAL //浮点数 TEXT\t//文本字符串 BLOB //blob数据，完全根据它的输入存储 SQLITE 亲和类型 TEXT 数值型在被插入前，需要先被转换为文本格式，再被插入到目标字段中 NUMERIC 当文本数据被插入到亲缘行为NUMERIC的字段中，如果转换操作不会导致数据信息丢失以及完全可逆，将该文本数据转换为INTEGER或REAL类型的数据。 如果转换失败，仍会以TEXT的方式存储。NULL BLOB不做任何转换，直接以NULL或BLOB的方式存储。 浮点数可以转换为整数类型而不会丢失数据信息，那么将以INTEGER的类型存储。 INTEGER 基本等同于NUMERIC REAL 数字以real存储，文本能转换则转换 NONE 不做任何转换 亲和类型及类型名称 亲和类型 数据类型 INTEGER INT INTEGERTINYINTSMALLINTMEDIUMINTBIGINTUNSIGNED BIG INTINT2 INT8 TEXT CHARACTER(20) VARCHAR(255)VARYING CHARACTER(255)NCHAR(55)NATIVE CHARACTER(70)\u003eNVARCHAR(100)TEXTCLOB BLOB BLOB 未指定 REAL REALDOUBLEDOUBLE PRECISIONFLOAT NUMERIC NUMERICDECIMAL(10,5)BOOLEANDATEDATETIME BOOLEAN sqlite 没有单独的boolean存储类型，整数0和1表示false和true DATRE \u0026 TIME sqlite 没有单独的用于存储日期和时间的存储类型，能够把日期表示为TEXT REAL INTEGER类型 sqlite3 DatabaseName.db .open test.db .quit sqlite3 testDB.db .dump \u003e testDB.sql sqlite2 testDB.db \u003c testDB.sql ATTACH DATABASE 'TESTdb.DB' AS \"TEST\"; .database DETACH DATABASE 'TEST'; .databases #创建表 CREATE TABLE database_name.table_name ( col1 datatype PRIMARY KEY(one or more columns), col2 datatype, ... ); CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL, ); .tables #删除表 DROP TABLE database_name.table_name; .tables DROP TABLE COMPANY; #在表中新增数据 INSERT INTO table_name [(col1,col2,col3,...)] VALUES (val1,val2,val3,...); INSERT INTO table_name VALUES(val1,val2,...); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1,'PAUL',32,'California',20000.00); INSERT INTO COMPANY VALUES (2,'Allen',23,\"Texas\",29998.9); INSERT INTO COMPANY [(col1,col2,col3,...)] SELECT col1,col2,col3,... FROM COMPANY2 [WHERE condition]; #SELECT 查询语句 SELECT col1,col2,... FROM table_name; SELECT * FROM COMPANY; SELECT ID,NAME,SALARY FROM COMPANY; SELECT tbl_name FROM sqlite_master WHERE type = \"table\"; SELECT sql FROM sqlite_master WHERE type =\"table\" AND tbl_name = \"COMPANY\"; #sqlite 表达式 SELECT CURRENT_TIMESTAMP; //日期表达式 SELECT (15 + 16) AS ADDITION; //数值表达式 SELECT * FROM COMPANY WHERE SALARY = 10000; //布尔表达式 #SELECT WHERE 语句 SELECT col1,col2,... FROM table_name WHERE [condition]; SELECT * FROM COMPANY WHERE AGE \u003e= 25 AND SALARY \u003e= 6500; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; SELECT * FROM COMPANY WHERE AGE \u003e= 35 OR SALARY \u003c= 22000; SELECT * FROM COMPANY WHERE NAME LIKE \"Ki%\"; SELECT * FROM COMPANY WHERE GLOB \"Ki*\"; SELECT * FROM COMPANY WHERE AGE IN (25,35); SELECT * FROM COMPANY WHERE AGE NOT IN (25,27); SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27; SELECT * FROM WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY \u003e 65000); SELECT * FROM COMPANY WHERE AGE \u003e (SELECT AGE FROM COMPANY WHERE SALARY \u003e 65000); #SELECT AND 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] AND [condition2] AND [conditon3]; SELECT * FROM COMPANY WHERE AGE \u003e= 25 AND SALARY \u003e= 65000; #SELECT OR 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] OR [condition2] OR [condition3]; SELECT * FROM COMPANY WHERE AGE \u003e= 25 OR SALARY \u003e= 65000; #更新标桩已有的数据 UPDATE table_name SET col1=val1, col2=val2, ... WHERE [condition]; UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6; UPDATE COMPANY SET ADDRESS = 'Texas',SALARY = 2000.00; #删除表中已有的记录 DELETE FROM tabel_name WHERE [condition]; DELETE FROM COMPANY WHERE ID = 1; DELETE FROM COMPANY; #删除全部数据 #限制select语句返回的数据数量 SELECT * FROM COMPANY LIMIT 6; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; #从第3个开始返回3个数据 #基于一列或多列进行排序 SELECT * FROM COMPANY ORDER BY SALARY ASC; SELECT * FROM COMPANY ORDER BY AGE DESC; SELECT * FROM COMPANY ORDER BY NAME,SALARY ASC; #对相同的数据进行分组 SELECT NAME,SUM(SALARY) FROM COMPANY GROUP BY NAME; SELECT NAME,SUM(SALARY) FROM COMAPNY GROUP BY NAME ORDER BY NAME; #指定条件过滤 SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) \u003e2; SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) \u003c2 ORDER BY NAME; #去重复 SELECT DISTINCT NAME FROM COMPANY; SQLITE PRAGMA PRAGMA [database.]auto_vacuum; PRAGMA [database.]auto_vacuum = mode; #mode 0 / NONE 默认模式，禁用auto_vacuum，数据库尺寸不会缩小，除非手动使用VACUUM命令 PRAGMA [database.]cache_size; PRAGMA [database.]cache_size = pages; #pages 表示在缓存中的页面数 PRAGMA case_sensitive_like = [true|false]; #控制like表达式的大小写敏感度 PRAGMA count_changes; PRAGMA count_changes = [true | false]; #pragma 获取或设置数据操作语句的返回值默认false不返回任何值 PRAGMA database_list; #列出所有的数据库连接 PRAGMA encoding; PRAGMA encoding = format; #格式可以是utf-8 utf-16 utf-16e之一 PRAGMA [database.]freelist_count; #当前被标记为免费和可用的数据库页面数 PRAGMA [database.]index_info(index_name); #返回关于数据库索引的信息 PRAGMA [database.]index_list(index_name); #列出所有与表相关的索引 PRAGMA journal_mode; PRAGMA journal_mode = mode; PRAGMA database.journal_mode; PRAGMA database.journal_mode = mode; #获取和设置控制日志文件如何存储和处理的日志模式 DELETE 默认模式，事物结束后，日志文件将被删除 TRUNCATE 日志文件被截断为0字节长度 PERSIST 日志文件被留在原地，但头部被重写，表明日志不再有效 MEMORY 日志记录保留在内存上，而不是磁盘上 OFF\t不保留任何日志记录 PRAGMA [database.]max_page_count; PRAGMA [database.]max_page_count = max_page; #获取和设置数据库允许的最大页树; PRAGMA [database.]page_count; #获取和设置当前数据库的网页数量 PRAGMA [database.]page_size; PRAGMA [database.]page_size = bytes; #数据库页面大小 512 1024 2048 4096 8192 32768 PRAGMA parser_trace = [true | false]; #随着解析SQL命令来控制打印的调试状态 PRAGMA recursive_triggers; PRAGMA recursive_triggers = [true| false]; #递归触发器功能 PRAGMA [database.]schema_version = number; #获取或设置存储在数据库头中的架构版本信息 PRAGMA secure_delete; PRAGMA secure_delete = [true | false]; PRAGMA [database.]secure_delete = [true | false]; #控制内容是如何从数据库中删除的 默认关闭 PRAGMA sql_trace; PRAGMA sql_trace = [true | false]; #用于把sql 跟踪结果转储到屏幕上 PRAGMA [database.]synchronous; PRAGMA [database.]synchronous = mode; # 获取或设置当前磁盘的同步模式 0 OFF 不进行同步 1 NORMAL 在关键的磁盘操作的每个序列后同步 2 FULL 在每个关键的磁盘操作后同步 PRAGMA temp_store; PRAGMA temp_store = mode; #获取或设置临时数据库文件所使用的存储模式 0 DEFAULT 默认使用编译时的模式 FILE 1 FILE 使用基于文件的存储 2 MEMORY 使用基于内存的存储 PRAGMA temp_store_directory; PRAGMA temp_store_directory = \"dir_path\"; #获取或设置用于临时数据库文件的位置 PRAGMA [database.]user_version = number; #获取或设置存储在数据库头的用户自定义的版本，可以由开发人员设置，用于版本跟踪的目的 PRAGMA writable_schema; PRAGMA writable_schema = [true|false]; #获取或设置是否能够修改系统表 SQLITE 约束 //NOT NULL //默认情况下列是可以保存NULL，可以指定该列上不允许存在NULL值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADRRESS CHAR(50), SALARY REAL ); //DEFAULT //在没有提供一个特定的值的时候，提供一个默认值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //UNIQUE //防止在一个特定的列存在的两个记录具有相同的值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL UNIQUE, ADRRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //PRIMARY KEY //约束唯一标识数据库中的每个记录，一个只能有一个主键 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); //CHECK //启用输入一条记录要检查值的条件，如果条件值为false,则记录违反了约束，且不能输入到表中 CREATE TABLE company ( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL CHECK(SALARY \u003e 0) ); //删除约束 ALTER TABLE table_name DROP CONSTRAINT primary_key_name; ALTER TABLE table_name DROP CONSTRAINT unique_constraint_name; ALTER TABLE table_name DROP CONSTRAINT foreign_key_constraint_name; SQLITE JOIN //CROSS JOIN //把第一个表的每一行与第二个表的每一行进行匹配 SELECT emp_id,name,dept FROM company CROSS JOIN department; //INNER JOIN //根据连接谓词结合两个表的列值来创建一个新的结果表,为默认的连接类型 SELECT emp_id,name,dept FROM company INNER JOIN deparment ON company.id = department.emp_id; //OUTER JOIN //INNER JOIN后使用NULL填充 SELECT emp_id,name,dept FROM compamy OUTER JOIN department ON company.id = department.id; SQLITE TRIGGER CREATE TRIGGER trigger_name [BEFORE|AFTER] [UPDATE|INSERT|DELETE] ON table_name BEGIN ...trigger logic END; CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); CREATE TABLE audit( emp_id INT NOT NULL, entry_date TEXT NOT NULL ); CREATE TRIGGER audit_log AFTER INSERT ON company BEGIN INSERT INTO audit VALUES (new.ID,datatime('now')); END; //列出触发器 SELECT * FROM sqlite_master WHERE type='trigger' AND tbl_name='company'; DROP TRIGGER trigger_name;//删除触发器 索引 一种特殊的查找表，数据库引擎用来加快数据检索，索引是指向表中数据的指针。 能够加快select where语句的速度，但会减慢update insert语句的数据输入 #单列索引 CREATE INDEX index_name ON table_name (column_name); #唯一索引 CREATE UNIQUE index_name ON table_name (column_name); #组合索引 CREATE INDEX index_name ON table_name (col1,col2,...); //隐式索引，创建对象时数据库自动创建的索引 //删除索引 DROP INDEX index_name; CREATE INDEX salary_index ON company (salary); .indices company SELECT * FROM slqite_master WHERE type = 'index'; DROP INDEX salary_index //使用索引查找 SELECT |DELETE | UPDATE col1,col2,... INDEXED BY (index_name) table_name WHERE (condition); SELECT * FROM company INDEXED BY salary_index WHERE salary \u003e 5000; SQLITE ALTER 用于修改表名字和添加列 ALTER TABLE database_name.table_name RENAME TO new_table_name; ALTER TABLE database_name.table_name ADD COLUMN column_def ...; SQLITE INCREMENT CREATE TABLE company( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INT NOT NULL, address CHAR(50), salary REAL );//AUTOINCREMENT 用于表中的字段值自动递增 SLQITE TRANSACTION BEGIN;COMMIT;ROLLBACK; //一个例子 BEGIN; DELETE FROM company WHERE age = 35; ROLLBACK; //取消删除 //一个例子 BEGIN; DELETE FROM company WHERE age = 34; COMMIT;//成功删除"},"title":"Sqlite"},"/blog/posts/ssh-keygen/":{"data":{"":"","ssh-keygen#ssh-keygen":"options -t 指定密钥类型 -b rsa制定密钥长度2048 4096 -f 制定输出文件名默认~/.ssh/id_ -C 为密钥添加注释 -N 为私钥设置密码 -p 更改密钥的指纹 -l 显示密钥的指纹 -y 从私钥输出公钥 -O 使用新格式 -I 指定证书的身份标识 -s 制定ca密钥用于签名证书 -Y 设置证书有效期 rsa密钥 ssh-keygen -t rsa -b 4096 -C \"user@example.com\" #添加公钥到服务器 ssh-copy-id user@remote_host #手动复制 cat ~/.ssh/id_rsa.pub \u003e\u003e ~/.ssh/authorized_keys ed25519密钥 ssh-keygen -t ed25519 -C \"user@example.com\" 查看密钥指纹 ssh-keygen -l -f ~/.ssh/id_rsa 添加或修改私钥的密码 ssh-keygen -p -f ~/.ssh/id_rsa 从私钥提取公钥 ssh-keygen -y -f ~/.ssh/id_rsa ssh证书 #常见ca证书 ssh-keygen -t ed25519 -f ssh_ca -C \"CA_key\" #生成用户密钥 ssh-keygen -t ed25519 -f user_key -C \"user_key\" #用ca签名用户公钥 ssh-keygen -s ssh_ca -I user_id -n user -V +1w user_key.pub #将ca公钥加入服务器的/etc/ssh/sshd_config #客户端使用证书登陆 ssh -i user_key -i user_key-cert.pub user@server 转换pem密钥格式 ssh-keygen -e -f ~/.ssh/id_rsa -m PEM \u003e id_rsa.pem ssh-keygen -i -f id_rsa.pem \u003e id_ras_openssh 为ssh服务器生成主机密钥 sudo ssh-keygen 0t ed25519 -f /etc/ssh/ssh_host_ed2519_key -N \"\" sudo systemctl restart sshd 签名和验证数据 echo \"hello,world\" \u003e data.txt ssh-keygen -Y sign -f ~/.ssh/id_ed25519 -n file data.txt ssh-keygen -Y verify -f ~/.ssh/id_ed25519.pub -n file -I user@example.com -s data.txt.sig \u003c data.txt 管理known_hosts ssh-keygen -R remote_host #从~/.ssh/known_hosts删除条目"},"title":"ssh-keygen"},"/blog/posts/ssh-nopasswd/":{"data":{"":"","ssh密钥登陆#ssh密钥登陆":"ssh-keygen -t ed25519 -N \"\" -C \"tongunas\" -f ~/.ssh/tongxunas_key ssh-copy-id -i ~/.ssh/tongxunas_key user@server ssh -i ~/.ssh/tongxunas_key user@server vim ~/.ssh/config Host myserver Hostname ip or Domain User user_name Port 22 IdentityFile ~/.ssh/tongxunas_key ssh myserver"},"title":"ssh-nopasswd login"},"/blog/posts/systemd/":{"data":{"":"","systemd#systemd":"systemd unit\n单元是systemd的最小功能单位，是但个进程的描述。一个个小的unit互相调用和依赖，组成一个庞大的人物管理系统。 unit分为不同的种类，大概有12种。service unit负责后台服务，timer unit负责定时器 每个单元都有一个单元描述文件，分散在3个目录 /lib/systemd/system /etc/systemd/system /usr/lib/systemd/system 查看所有的单元文件 systemctl list-unit-files systemctl list-unit-files –type service systemctl list-unit-files –type timer 单元管理命令 system start/stop/restart/kill/status/enable/disable [unitName] Service unit\n在/usr/lib/systemd/system目录里面新建一个文件，比如mytimer.service [Unit] Description=MyTimer [Service] ExecStart=/bin/bash /path/to/mail.sh [Unit]介绍单元的基本信息，Description给出这个单元的简介 [Service]用来定制行为，Systemd提供许多字段 ExecStart, ExecStop, ExecReload, ExecStartPre, ExecStartPost, ExecStopPost Timer单元\n在/usr/lib/systemd/system目录里面 新建一个mytimer.timer文件 [Unit] Description=Runs mytimer every hour [Timer] OnUnitActiveSec=1h Unit=mytimer.service [Install] WantedBy=multi-user.target [Timer]定制定时器部分 OnActiveSec 定时器生效后，多少时间开始执行任务 OnBootSec 系统启动后，多少时间开始执行任务 OnStartupSec systemd进程启动后多少时间开始执行任务 OnUnitActiveSec 该单元上次执行后，等多少时间再次执行 OnUnitInactiveSec 定时器上次关闭多少时间，再次执行 OnCalendar 基于绝对时间 AccuracySec 如果因为各种原因，任务必须推迟，推迟的最大秒数，默认60秒 Unit 真正要执行的任务，默认是同名的.service单元 Persistent 即使定时器到时没启动也会自动执行相应的单元 WakeSystem 如果系统休眠，是否自动唤醒系统 定时器的相关命令 sudo systemctl start mytimer.timer systemctl status mytimer.timer systemctl list-timers sudo systemctl stop mytimer.timer sudo systemctl enable mytimer.timer sudo systemctl disable mytimer.timer"},"title":"Systemd"},"/blog/posts/xargs/":{"data":{"":"","xargs命令#xargs命令":"将标准输入转换为命令行参数 #grep可以接受标准输入作为参数 cat /etc/passwd | grep root # grep root /etc/passwd #echo不接受标准输入作为参数 echo \"hello world\" | echo 执行错误 xargs的单独使用 xargs == xargs echo # 后面的命令默认为echo #xargs 执行后输入hello,按ctr+D 执行echo打印 xargs hello(^D) hello # $xargs find -name \"*.txt\" ./foo.txt ./hello.txt -d参数与分隔符 #默认使用换行符和空格作为分隔符，把标准输入分解成一个个命令行参数 echo \"one two three\" | xargs mkdir #使用制表符作为分隔符 echo -e \"a\\tb\\tc\" | xargs -d \"\\t\" echo -p 与 -t参数 #-p打印出要执行的命令，询问是否执行，输入y后才会正真执行 echo \"one two three\" | xargs -p touch $touch one two three?... #询问是否执行 #-t打印出最终要执行的命令，直接执行，不需要用户确认 echo \"one two three\" | xargs -t rm $rm one two three #打印并直接执行 -0参数与find的配合 #print0 制定输出的文件列表以null分隔，xargs -0 参数表示用null作为分隔符 find /path -type f -print0 | xargs -0 rm -L参数与-n参数 #标准输入包含多行时，-L指定多少行作为一个命令行参数 xargs find -name \"*.txt\" \"*.md\" #报错 find 命令不能同时接受两个通配符 #使用-L参数指定每一行作为一个命令行参数，就不会报错 xargs -L 1 find -name \"*.txt\" $./foo.txt $./hello.txt \"*.md\" $./README.md #同一行输入多项，使用-n参数指定每次将动少项作为命令行参数 xargs -n 1 find -name \"*.txt\" \"*.md\" -I参数 将命令行参数传给多个命令 cat foo.txt | xargs -I file sh -c \"echo file;mkdir file\" #-I file中file是命令行参数的替代字符串 –max-procs 参数 #默认xargs只使用一个进程执行命令，如果命令要执行多次，必须等上一次的命令执行玩，才能执行下一次 docker ps -q | xargs -n 1 --max-procs 0 docker kill #--max-procs 0表示不限制进程数量 #--max-procs 2表示使用2个进程执行命令"},"title":"Xargs"}}