<!doctype html>







<html
  class="not-ready lg:text-base"
  style="--bg:#faf8f1"
  lang="en-us"
  dir="ltr"
><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Sqlite-TongXu-Server</title>

  
  <meta name="theme-color" />

  <meta name="description" content="sqlite3 db

sqlite3 命令

.help #获取可用命令的清单
.show #显示当前各种设置的值
.timeout MS #尝试打开锁定的表的时间

.timer on/off #开启或关闭cpu定时器
.width NUM NUM  #为column 模式设置列宽度
.mode MODE # csv,column,html,line,list,tabs,tcl 
.stats on|off  #开启或关闭统计
.header on/off #开启或关闭头部显示
.echo on/off #开启或关闭echo命令

.tables #列出表的名称
.databases #列出数据库的名称极其所依附的文件
.quit #退出sqlite提示符
.exit #退出sqlite提示符

.schema sqlite_master #主表中保存数据库的关键信息，并把它命名为sqlite_master

SQLITE 数据类型

NULL  		//Null值
INTEGER	   //有符号整数
REAL                 //浮点数
TEXT		 //文本字符串
BLOB               //blob数据，完全根据它的输入存储


SQLITE 亲和类型

TEXT 数值型在被插入前，需要先被转换为文本格式，再被插入到目标字段中
NUMERIC 当文本数据被插入到亲缘行为NUMERIC的字段中，如果转换操作不会导致数据信息丢失以及完全可逆，将该文本数据转换为INTEGER或REAL类型的数据。 如果转换失败，仍会以TEXT的方式存储。NULL BLOB不做任何转换，直接以NULL或BLOB的方式存储。 浮点数可以转换为整数类型而不会丢失数据信息，那么将以INTEGER的类型存储。
INTEGER  基本等同于NUMERIC
REAL     数字以real存储，文本能转换则转换
NONE  不做任何转换


亲和类型及类型名称


  
      
          亲和类型
          数据类型
      
  
  
      
          INTEGER
          INT INTEGERTINYINTSMALLINTMEDIUMINTBIGINTUNSIGNED  BIG INTINT2 INT8
      
      
          TEXT
          CHARACTER(20) VARCHAR(255)VARYING CHARACTER(255)NCHAR(55)NATIVE CHARACTER(70)&gt;NVARCHAR(100)TEXTCLOB
      
      
          BLOB
          BLOB 未指定
      
      
          REAL
          REALDOUBLEDOUBLE PRECISIONFLOAT
      
      
          NUMERIC
          NUMERICDECIMAL(10,5)BOOLEANDATEDATETIME
      
  


BOOLEAN

sqlite 没有单独的boolean存储类型，整数0和1表示false和true


DATRE &amp; TIME

sqlite 没有单独的用于存储日期和时间的存储类型，能够把日期表示为TEXT REAL INTEGER类型



sqlite3 DatabaseName.db
.open test.db
.quit

sqlite3 testDB.db .dump &gt; testDB.sql
sqlite2 testDB.db &lt; testDB.sql

ATTACH DATABASE &#39;TESTdb.DB&#39; AS &#34;TEST&#34;;
.database
DETACH DATABASE &#39;TEST&#39;;
.databases
#创建表
CREATE TABLE database_name.table_name (
	col1 datatype PRIMARY KEY(one or more columns),
    col2 datatype,
    ...
);
CREATE TABLE COMPANY(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL,
);
.tables

#删除表
DROP TABLE database_name.table_name;
.tables
DROP TABLE COMPANY;

#在表中新增数据
INSERT INTO table_name [(col1,col2,col3,...)] VALUES (val1,val2,val3,...);
INSERT INTO table_name VALUES(val1,val2,...);
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1,&#39;PAUL&#39;,32,&#39;California&#39;,20000.00);
INSERT INTO COMPANY VALUES (2,&#39;Allen&#39;,23,&#34;Texas&#34;,29998.9);
INSERT INTO COMPANY [(col1,col2,col3,...)] SELECT col1,col2,col3,... FROM COMPANY2 [WHERE condition];

#SELECT 查询语句
SELECT col1,col2,... FROM table_name;
SELECT * FROM COMPANY;
SELECT ID,NAME,SALARY FROM COMPANY;
SELECT tbl_name FROM  sqlite_master WHERE type = &#34;table&#34;;
SELECT sql FROM sqlite_master WHERE type =&#34;table&#34; AND tbl_name = &#34;COMPANY&#34;;

#sqlite 表达式
SELECT CURRENT_TIMESTAMP; //日期表达式
SELECT (15 &#43; 16) AS ADDITION; //数值表达式
SELECT * FROM COMPANY WHERE SALARY = 10000; //布尔表达式

#SELECT WHERE 语句
SELECT col1,col2,... FROM table_name WHERE [condition];
SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 6500;
SELECT * FROM COMPANY WHERE AGE IS NOT NULL;
SELECT * FROM COMPANY WHERE AGE &gt;= 35 OR SALARY &lt;= 22000;
SELECT * FROM COMPANY WHERE NAME LIKE &#34;Ki%&#34;;
SELECT * FROM COMPANY WHERE GLOB &#34;Ki*&#34;;
SELECT * FROM COMPANY WHERE AGE IN (25,35);
SELECT * FROM COMPANY WHERE AGE NOT IN (25,27);
SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;
SELECT * FROM WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);
SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);

#SELECT AND 运算符
SELECT col1,col2,... FROM table_name WHERE [condition1] AND [condition2] AND [conditon3];
SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;
#SELECT OR 运算符
SELECT col1,col2,... FROM table_name WHERE [condition1] OR [condition2] OR [condition3];
SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;

#更新标桩已有的数据
UPDATE table_name SET col1=val1, col2=val2, ... WHERE [condition];
UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6;
UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;,SALARY = 2000.00;

#删除表中已有的记录
DELETE FROM tabel_name WHERE [condition];
DELETE FROM COMPANY WHERE ID = 1;
DELETE FROM COMPANY; #删除全部数据

#限制select语句返回的数据数量
SELECT * FROM COMPANY LIMIT 6;
SELECT * FROM COMPANY LIMIT 3 OFFSET 2;  #从第3个开始返回3个数据

#基于一列或多列进行排序
SELECT * FROM COMPANY ORDER BY SALARY ASC;
SELECT * FROM COMPANY ORDER BY AGE DESC;
SELECT * FROM COMPANY ORDER BY NAME,SALARY ASC;

#对相同的数据进行分组
SELECT NAME,SUM(SALARY) FROM COMPANY GROUP BY NAME;
SELECT NAME,SUM(SALARY) FROM COMAPNY GROUP BY NAME ORDER BY NAME;

#指定条件过滤
SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &gt;2;
SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &lt;2 ORDER BY NAME;

#去重复
SELECT DISTINCT NAME FROM COMPANY;

SQLITE PRAGMA

PRAGMA [database.]auto_vacuum;
PRAGMA [database.]auto_vacuum = mode;
#mode 0 / NONE  默认模式，禁用auto_vacuum，数据库尺寸不会缩小，除非手动使用VACUUM命令

PRAGMA [database.]cache_size;
PRAGMA [database.]cache_size = pages;
#pages 表示在缓存中的页面数

PRAGMA case_sensitive_like = [true|false];
#控制like表达式的大小写敏感度

PRAGMA count_changes;
PRAGMA count_changes = [true | false];
#pragma 获取或设置数据操作语句的返回值默认false不返回任何值

PRAGMA database_list;
#列出所有的数据库连接

PRAGMA encoding;
PRAGMA encoding = format;
#格式可以是utf-8 utf-16 utf-16e之一

PRAGMA [database.]freelist_count;
#当前被标记为免费和可用的数据库页面数

PRAGMA [database.]index_info(index_name);
#返回关于数据库索引的信息

PRAGMA [database.]index_list(index_name);
#列出所有与表相关的索引

PRAGMA journal_mode;
PRAGMA journal_mode = mode;
PRAGMA database.journal_mode;
PRAGMA database.journal_mode = mode;
#获取和设置控制日志文件如何存储和处理的日志模式
DELETE 默认模式，事物结束后，日志文件将被删除
TRUNCATE 日志文件被截断为0字节长度
PERSIST 日志文件被留在原地，但头部被重写，表明日志不再有效
MEMORY 日志记录保留在内存上，而不是磁盘上
OFF		不保留任何日志记录

PRAGMA [database.]max_page_count;
PRAGMA [database.]max_page_count = max_page;
#获取和设置数据库允许的最大页树;

PRAGMA [database.]page_count;
#获取和设置当前数据库的网页数量

PRAGMA [database.]page_size;
PRAGMA [database.]page_size = bytes;
#数据库页面大小  512 1024 2048 4096 8192 32768

PRAGMA parser_trace = [true | false];
#随着解析SQL命令来控制打印的调试状态

PRAGMA recursive_triggers;
PRAGMA recursive_triggers = [true| false];
#递归触发器功能

PRAGMA [database.]schema_version = number;
#获取或设置存储在数据库头中的架构版本信息

PRAGMA secure_delete;
PRAGMA secure_delete = [true | false];
PRAGMA [database.]secure_delete = [true | false];
#控制内容是如何从数据库中删除的 默认关闭

PRAGMA sql_trace;
PRAGMA sql_trace = [true | false];
#用于把sql 跟踪结果转储到屏幕上

PRAGMA [database.]synchronous;
PRAGMA [database.]synchronous = mode;
# 获取或设置当前磁盘的同步模式
0 OFF 不进行同步
1 NORMAL 在关键的磁盘操作的每个序列后同步
2 FULL 在每个关键的磁盘操作后同步

PRAGMA temp_store;
PRAGMA temp_store = mode;
#获取或设置临时数据库文件所使用的存储模式
0 DEFAULT 默认使用编译时的模式 FILE
1 FILE    使用基于文件的存储
2 MEMORY  使用基于内存的存储

PRAGMA temp_store_directory;
PRAGMA temp_store_directory = &#34;dir_path&#34;;
#获取或设置用于临时数据库文件的位置

PRAGMA [database.]user_version = number;
#获取或设置存储在数据库头的用户自定义的版本，可以由开发人员设置，用于版本跟踪的目的

PRAGMA writable_schema;
PRAGMA writable_schema = [true|false];
#获取或设置是否能够修改系统表

SQLITE 约束

//NOT NULL
//默认情况下列是可以保存NULL，可以指定该列上不允许存在NULL值
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL, 
    ADRRESS CHAR(50),
    SALARY REAL
);
//DEFAULT
//在没有提供一个特定的值的时候，提供一个默认值
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL DEFAULT 50000.00
);
//UNIQUE
//防止在一个特定的列存在的两个记录具有相同的值
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL UNIQUE,
    ADRRESS CHAR(50),
    SALARY REAL DEFAULT 50000.00
);
//PRIMARY KEY
//约束唯一标识数据库中的每个记录，一个只能有一个主键
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL
);
//CHECK
//启用输入一条记录要检查值的条件，如果条件值为false,则记录违反了约束，且不能输入到表中
CREATE TABLE company (
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL CHECK(SALARY &gt; 0)
);
//删除约束
ALTER TABLE table_name DROP CONSTRAINT primary_key_name;
ALTER TABLE table_name DROP CONSTRAINT unique_constraint_name;
ALTER TABLE table_name DROP  CONSTRAINT foreign_key_constraint_name;

SQLITE JOIN

//CROSS JOIN 
//把第一个表的每一行与第二个表的每一行进行匹配
SELECT emp_id,name,dept FROM company CROSS JOIN department;

//INNER JOIN
//根据连接谓词结合两个表的列值来创建一个新的结果表,为默认的连接类型
SELECT emp_id,name,dept FROM company INNER JOIN deparment ON company.id = department.emp_id;

//OUTER JOIN
//INNER JOIN后使用NULL填充
SELECT emp_id,name,dept FROM  compamy OUTER JOIN department ON company.id = department.id;

SQLITE TRIGGER

CREATE TRIGGER trigger_name [BEFORE|AFTER] [UPDATE|INSERT|DELETE]
ON table_name
BEGIN
	...trigger logic 
END;


CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL
);

CREATE TABLE audit(
	emp_id INT NOT NULL,
    entry_date TEXT NOT NULL
);

CREATE TRIGGER audit_log AFTER INSERT ON company
BEGIN
	INSERT INTO audit VALUES (new.ID,datatime(&#39;now&#39;));
END;

//列出触发器
SELECT * FROM sqlite_master WHERE type=&#39;trigger&#39; AND tbl_name=&#39;company&#39;;
DROP TRIGGER trigger_name;//删除触发器

索引
一种特殊的查找表，数据库引擎用来加快数据检索，索引是指向表中数据的指针。
能够加快select  where语句的速度，但会减慢update insert语句的数据输入

#单列索引
CREATE INDEX index_name ON table_name (column_name);
#唯一索引
CREATE UNIQUE index_name ON table_name (column_name);
#组合索引
CREATE INDEX index_name ON table_name (col1,col2,...);

//隐式索引，创建对象时数据库自动创建的索引

//删除索引
DROP INDEX index_name;


CREATE INDEX salary_index ON company (salary);
.indices company
SELECT * FROM slqite_master WHERE type = &#39;index&#39;;
DROP INDEX salary_index


//使用索引查找
SELECT |DELETE | UPDATE col1,col2,...
INDEXED BY (index_name)
table_name
WHERE (condition);

SELECT * FROM company INDEXED BY salary_index WHERE salary &gt; 5000;

SQLITE ALTER
用于修改表名字和添加列

ALTER TABLE database_name.table_name RENAME TO new_table_name;
ALTER TABLE database_name.table_name ADD COLUMN column_def ...;

SQLITE INCREMENT

CREATE TABLE company(
	id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INT NOT NULL,
    address CHAR(50),
    salary REAL
);//AUTOINCREMENT 用于表中的字段值自动递增

SLQITE TRANSACTION

BEGIN;COMMIT;ROLLBACK;

//一个例子
BEGIN;
DELETE FROM company WHERE age = 35;
ROLLBACK; //取消删除

//一个例子
BEGIN;
DELETE FROM company WHERE age = 34;
COMMIT;//成功删除
" />
  <meta name="author" content="TongXu-Server" /><link rel="preload stylesheet" as="style" href="https://bjmu1026.github.io/blog/main.min.css" />

  
  <link rel="preload" as="image" href="https://bjmu1026.github.io/blog/theme.png" />

  

  

  <script
    defer
    src="https://bjmu1026.github.io/blog/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>

  
  <link
    rel="icon"
    href="https://bjmu1026.github.io/blog/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="https://bjmu1026.github.io/blog/apple-touch-icon.png"
  />

  <meta name="generator" content="Hugo 0.150.0">
  <meta itemprop="name" content="Sqlite">
  <meta itemprop="description" content="sqlite3 db sqlite3 命令 .help #获取可用命令的清单 .show #显示当前各种设置的值 .timeout MS #尝试打开锁定的表的时间 .timer on/off #开启或关闭cpu定时器 .width NUM NUM #为column 模式设置列宽度 .mode MODE # csv,column,html,line,list,tabs,tcl .stats on|off #开启或关闭统计 .header on/off #开启或关闭头部显示 .echo on/off #开启或关闭echo命令 .tables #列出表的名称 .databases #列出数据库的名称极其所依附的文件 .quit #退出sqlite提示符 .exit #退出sqlite提示符 .schema sqlite_master #主表中保存数据库的关键信息，并把它命名为sqlite_master SQLITE 数据类型 NULL //Null值 INTEGER	//有符号整数 REAL //浮点数 TEXT	//文本字符串 BLOB //blob数据，完全根据它的输入存储 SQLITE 亲和类型 TEXT 数值型在被插入前，需要先被转换为文本格式，再被插入到目标字段中 NUMERIC 当文本数据被插入到亲缘行为NUMERIC的字段中，如果转换操作不会导致数据信息丢失以及完全可逆，将该文本数据转换为INTEGER或REAL类型的数据。 如果转换失败，仍会以TEXT的方式存储。NULL BLOB不做任何转换，直接以NULL或BLOB的方式存储。 浮点数可以转换为整数类型而不会丢失数据信息，那么将以INTEGER的类型存储。 INTEGER 基本等同于NUMERIC REAL 数字以real存储，文本能转换则转换 NONE 不做任何转换 亲和类型及类型名称 亲和类型 数据类型 INTEGER INT INTEGERTINYINTSMALLINTMEDIUMINTBIGINTUNSIGNED BIG INTINT2 INT8 TEXT CHARACTER(20) VARCHAR(255)VARYING CHARACTER(255)NCHAR(55)NATIVE CHARACTER(70)&gt;NVARCHAR(100)TEXTCLOB BLOB BLOB 未指定 REAL REALDOUBLEDOUBLE PRECISIONFLOAT NUMERIC NUMERICDECIMAL(10,5)BOOLEANDATEDATETIME BOOLEAN sqlite 没有单独的boolean存储类型，整数0和1表示false和true DATRE &amp; TIME sqlite 没有单独的用于存储日期和时间的存储类型，能够把日期表示为TEXT REAL INTEGER类型 sqlite3 DatabaseName.db .open test.db .quit sqlite3 testDB.db .dump &gt; testDB.sql sqlite2 testDB.db &lt; testDB.sql ATTACH DATABASE &#39;TESTdb.DB&#39; AS &#34;TEST&#34;; .database DETACH DATABASE &#39;TEST&#39;; .databases #创建表 CREATE TABLE database_name.table_name ( col1 datatype PRIMARY KEY(one or more columns), col2 datatype, ... ); CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL, ); .tables #删除表 DROP TABLE database_name.table_name; .tables DROP TABLE COMPANY; #在表中新增数据 INSERT INTO table_name [(col1,col2,col3,...)] VALUES (val1,val2,val3,...); INSERT INTO table_name VALUES(val1,val2,...); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1,&#39;PAUL&#39;,32,&#39;California&#39;,20000.00); INSERT INTO COMPANY VALUES (2,&#39;Allen&#39;,23,&#34;Texas&#34;,29998.9); INSERT INTO COMPANY [(col1,col2,col3,...)] SELECT col1,col2,col3,... FROM COMPANY2 [WHERE condition]; #SELECT 查询语句 SELECT col1,col2,... FROM table_name; SELECT * FROM COMPANY; SELECT ID,NAME,SALARY FROM COMPANY; SELECT tbl_name FROM sqlite_master WHERE type = &#34;table&#34;; SELECT sql FROM sqlite_master WHERE type =&#34;table&#34; AND tbl_name = &#34;COMPANY&#34;; #sqlite 表达式 SELECT CURRENT_TIMESTAMP; //日期表达式 SELECT (15 &#43; 16) AS ADDITION; //数值表达式 SELECT * FROM COMPANY WHERE SALARY = 10000; //布尔表达式 #SELECT WHERE 语句 SELECT col1,col2,... FROM table_name WHERE [condition]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 6500; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; SELECT * FROM COMPANY WHERE AGE &gt;= 35 OR SALARY &lt;= 22000; SELECT * FROM COMPANY WHERE NAME LIKE &#34;Ki%&#34;; SELECT * FROM COMPANY WHERE GLOB &#34;Ki*&#34;; SELECT * FROM COMPANY WHERE AGE IN (25,35); SELECT * FROM COMPANY WHERE AGE NOT IN (25,27); SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27; SELECT * FROM WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); #SELECT AND 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] AND [condition2] AND [conditon3]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; #SELECT OR 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] OR [condition2] OR [condition3]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; #更新标桩已有的数据 UPDATE table_name SET col1=val1, col2=val2, ... WHERE [condition]; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;,SALARY = 2000.00; #删除表中已有的记录 DELETE FROM tabel_name WHERE [condition]; DELETE FROM COMPANY WHERE ID = 1; DELETE FROM COMPANY; #删除全部数据 #限制select语句返回的数据数量 SELECT * FROM COMPANY LIMIT 6; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; #从第3个开始返回3个数据 #基于一列或多列进行排序 SELECT * FROM COMPANY ORDER BY SALARY ASC; SELECT * FROM COMPANY ORDER BY AGE DESC; SELECT * FROM COMPANY ORDER BY NAME,SALARY ASC; #对相同的数据进行分组 SELECT NAME,SUM(SALARY) FROM COMPANY GROUP BY NAME; SELECT NAME,SUM(SALARY) FROM COMAPNY GROUP BY NAME ORDER BY NAME; #指定条件过滤 SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &gt;2; SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &lt;2 ORDER BY NAME; #去重复 SELECT DISTINCT NAME FROM COMPANY; SQLITE PRAGMA PRAGMA [database.]auto_vacuum; PRAGMA [database.]auto_vacuum = mode; #mode 0 / NONE 默认模式，禁用auto_vacuum，数据库尺寸不会缩小，除非手动使用VACUUM命令 PRAGMA [database.]cache_size; PRAGMA [database.]cache_size = pages; #pages 表示在缓存中的页面数 PRAGMA case_sensitive_like = [true|false]; #控制like表达式的大小写敏感度 PRAGMA count_changes; PRAGMA count_changes = [true | false]; #pragma 获取或设置数据操作语句的返回值默认false不返回任何值 PRAGMA database_list; #列出所有的数据库连接 PRAGMA encoding; PRAGMA encoding = format; #格式可以是utf-8 utf-16 utf-16e之一 PRAGMA [database.]freelist_count; #当前被标记为免费和可用的数据库页面数 PRAGMA [database.]index_info(index_name); #返回关于数据库索引的信息 PRAGMA [database.]index_list(index_name); #列出所有与表相关的索引 PRAGMA journal_mode; PRAGMA journal_mode = mode; PRAGMA database.journal_mode; PRAGMA database.journal_mode = mode; #获取和设置控制日志文件如何存储和处理的日志模式 DELETE 默认模式，事物结束后，日志文件将被删除 TRUNCATE 日志文件被截断为0字节长度 PERSIST 日志文件被留在原地，但头部被重写，表明日志不再有效 MEMORY 日志记录保留在内存上，而不是磁盘上 OFF	不保留任何日志记录 PRAGMA [database.]max_page_count; PRAGMA [database.]max_page_count = max_page; #获取和设置数据库允许的最大页树; PRAGMA [database.]page_count; #获取和设置当前数据库的网页数量 PRAGMA [database.]page_size; PRAGMA [database.]page_size = bytes; #数据库页面大小 512 1024 2048 4096 8192 32768 PRAGMA parser_trace = [true | false]; #随着解析SQL命令来控制打印的调试状态 PRAGMA recursive_triggers; PRAGMA recursive_triggers = [true| false]; #递归触发器功能 PRAGMA [database.]schema_version = number; #获取或设置存储在数据库头中的架构版本信息 PRAGMA secure_delete; PRAGMA secure_delete = [true | false]; PRAGMA [database.]secure_delete = [true | false]; #控制内容是如何从数据库中删除的 默认关闭 PRAGMA sql_trace; PRAGMA sql_trace = [true | false]; #用于把sql 跟踪结果转储到屏幕上 PRAGMA [database.]synchronous; PRAGMA [database.]synchronous = mode; # 获取或设置当前磁盘的同步模式 0 OFF 不进行同步 1 NORMAL 在关键的磁盘操作的每个序列后同步 2 FULL 在每个关键的磁盘操作后同步 PRAGMA temp_store; PRAGMA temp_store = mode; #获取或设置临时数据库文件所使用的存储模式 0 DEFAULT 默认使用编译时的模式 FILE 1 FILE 使用基于文件的存储 2 MEMORY 使用基于内存的存储 PRAGMA temp_store_directory; PRAGMA temp_store_directory = &#34;dir_path&#34;; #获取或设置用于临时数据库文件的位置 PRAGMA [database.]user_version = number; #获取或设置存储在数据库头的用户自定义的版本，可以由开发人员设置，用于版本跟踪的目的 PRAGMA writable_schema; PRAGMA writable_schema = [true|false]; #获取或设置是否能够修改系统表 SQLITE 约束 //NOT NULL //默认情况下列是可以保存NULL，可以指定该列上不允许存在NULL值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADRRESS CHAR(50), SALARY REAL ); //DEFAULT //在没有提供一个特定的值的时候，提供一个默认值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //UNIQUE //防止在一个特定的列存在的两个记录具有相同的值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL UNIQUE, ADRRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //PRIMARY KEY //约束唯一标识数据库中的每个记录，一个只能有一个主键 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); //CHECK //启用输入一条记录要检查值的条件，如果条件值为false,则记录违反了约束，且不能输入到表中 CREATE TABLE company ( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL CHECK(SALARY &gt; 0) ); //删除约束 ALTER TABLE table_name DROP CONSTRAINT primary_key_name; ALTER TABLE table_name DROP CONSTRAINT unique_constraint_name; ALTER TABLE table_name DROP CONSTRAINT foreign_key_constraint_name; SQLITE JOIN //CROSS JOIN //把第一个表的每一行与第二个表的每一行进行匹配 SELECT emp_id,name,dept FROM company CROSS JOIN department; //INNER JOIN //根据连接谓词结合两个表的列值来创建一个新的结果表,为默认的连接类型 SELECT emp_id,name,dept FROM company INNER JOIN deparment ON company.id = department.emp_id; //OUTER JOIN //INNER JOIN后使用NULL填充 SELECT emp_id,name,dept FROM compamy OUTER JOIN department ON company.id = department.id; SQLITE TRIGGER CREATE TRIGGER trigger_name [BEFORE|AFTER] [UPDATE|INSERT|DELETE] ON table_name BEGIN ...trigger logic END; CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); CREATE TABLE audit( emp_id INT NOT NULL, entry_date TEXT NOT NULL ); CREATE TRIGGER audit_log AFTER INSERT ON company BEGIN INSERT INTO audit VALUES (new.ID,datatime(&#39;now&#39;)); END; //列出触发器 SELECT * FROM sqlite_master WHERE type=&#39;trigger&#39; AND tbl_name=&#39;company&#39;; DROP TRIGGER trigger_name;//删除触发器 索引 一种特殊的查找表，数据库引擎用来加快数据检索，索引是指向表中数据的指针。 能够加快select where语句的速度，但会减慢update insert语句的数据输入 #单列索引 CREATE INDEX index_name ON table_name (column_name); #唯一索引 CREATE UNIQUE index_name ON table_name (column_name); #组合索引 CREATE INDEX index_name ON table_name (col1,col2,...); //隐式索引，创建对象时数据库自动创建的索引 //删除索引 DROP INDEX index_name; CREATE INDEX salary_index ON company (salary); .indices company SELECT * FROM slqite_master WHERE type = &#39;index&#39;; DROP INDEX salary_index //使用索引查找 SELECT |DELETE | UPDATE col1,col2,... INDEXED BY (index_name) table_name WHERE (condition); SELECT * FROM company INDEXED BY salary_index WHERE salary &gt; 5000; SQLITE ALTER 用于修改表名字和添加列 ALTER TABLE database_name.table_name RENAME TO new_table_name; ALTER TABLE database_name.table_name ADD COLUMN column_def ...; SQLITE INCREMENT CREATE TABLE company( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INT NOT NULL, address CHAR(50), salary REAL );//AUTOINCREMENT 用于表中的字段值自动递增 SLQITE TRANSACTION BEGIN;COMMIT;ROLLBACK; //一个例子 BEGIN; DELETE FROM company WHERE age = 35; ROLLBACK; //取消删除 //一个例子 BEGIN; DELETE FROM company WHERE age = 34; COMMIT;//成功删除">
  <meta itemprop="datePublished" content="2025-09-20T22:00:24+08:00">
  <meta itemprop="dateModified" content="2025-09-20T22:00:24+08:00">
  <meta itemprop="wordCount" content="1159"><meta property="og:url" content="https://bjmu1026.github.io/blog/posts/sqlite/">
  <meta property="og:site_name" content="TongXu-Server">
  <meta property="og:title" content="Sqlite">
  <meta property="og:description" content="sqlite3 db sqlite3 命令 .help #获取可用命令的清单 .show #显示当前各种设置的值 .timeout MS #尝试打开锁定的表的时间 .timer on/off #开启或关闭cpu定时器 .width NUM NUM #为column 模式设置列宽度 .mode MODE # csv,column,html,line,list,tabs,tcl .stats on|off #开启或关闭统计 .header on/off #开启或关闭头部显示 .echo on/off #开启或关闭echo命令 .tables #列出表的名称 .databases #列出数据库的名称极其所依附的文件 .quit #退出sqlite提示符 .exit #退出sqlite提示符 .schema sqlite_master #主表中保存数据库的关键信息，并把它命名为sqlite_master SQLITE 数据类型 NULL //Null值 INTEGER	//有符号整数 REAL //浮点数 TEXT	//文本字符串 BLOB //blob数据，完全根据它的输入存储 SQLITE 亲和类型 TEXT 数值型在被插入前，需要先被转换为文本格式，再被插入到目标字段中 NUMERIC 当文本数据被插入到亲缘行为NUMERIC的字段中，如果转换操作不会导致数据信息丢失以及完全可逆，将该文本数据转换为INTEGER或REAL类型的数据。 如果转换失败，仍会以TEXT的方式存储。NULL BLOB不做任何转换，直接以NULL或BLOB的方式存储。 浮点数可以转换为整数类型而不会丢失数据信息，那么将以INTEGER的类型存储。 INTEGER 基本等同于NUMERIC REAL 数字以real存储，文本能转换则转换 NONE 不做任何转换 亲和类型及类型名称 亲和类型 数据类型 INTEGER INT INTEGERTINYINTSMALLINTMEDIUMINTBIGINTUNSIGNED BIG INTINT2 INT8 TEXT CHARACTER(20) VARCHAR(255)VARYING CHARACTER(255)NCHAR(55)NATIVE CHARACTER(70)&gt;NVARCHAR(100)TEXTCLOB BLOB BLOB 未指定 REAL REALDOUBLEDOUBLE PRECISIONFLOAT NUMERIC NUMERICDECIMAL(10,5)BOOLEANDATEDATETIME BOOLEAN sqlite 没有单独的boolean存储类型，整数0和1表示false和true DATRE &amp; TIME sqlite 没有单独的用于存储日期和时间的存储类型，能够把日期表示为TEXT REAL INTEGER类型 sqlite3 DatabaseName.db .open test.db .quit sqlite3 testDB.db .dump &gt; testDB.sql sqlite2 testDB.db &lt; testDB.sql ATTACH DATABASE &#39;TESTdb.DB&#39; AS &#34;TEST&#34;; .database DETACH DATABASE &#39;TEST&#39;; .databases #创建表 CREATE TABLE database_name.table_name ( col1 datatype PRIMARY KEY(one or more columns), col2 datatype, ... ); CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL, ); .tables #删除表 DROP TABLE database_name.table_name; .tables DROP TABLE COMPANY; #在表中新增数据 INSERT INTO table_name [(col1,col2,col3,...)] VALUES (val1,val2,val3,...); INSERT INTO table_name VALUES(val1,val2,...); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1,&#39;PAUL&#39;,32,&#39;California&#39;,20000.00); INSERT INTO COMPANY VALUES (2,&#39;Allen&#39;,23,&#34;Texas&#34;,29998.9); INSERT INTO COMPANY [(col1,col2,col3,...)] SELECT col1,col2,col3,... FROM COMPANY2 [WHERE condition]; #SELECT 查询语句 SELECT col1,col2,... FROM table_name; SELECT * FROM COMPANY; SELECT ID,NAME,SALARY FROM COMPANY; SELECT tbl_name FROM sqlite_master WHERE type = &#34;table&#34;; SELECT sql FROM sqlite_master WHERE type =&#34;table&#34; AND tbl_name = &#34;COMPANY&#34;; #sqlite 表达式 SELECT CURRENT_TIMESTAMP; //日期表达式 SELECT (15 &#43; 16) AS ADDITION; //数值表达式 SELECT * FROM COMPANY WHERE SALARY = 10000; //布尔表达式 #SELECT WHERE 语句 SELECT col1,col2,... FROM table_name WHERE [condition]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 6500; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; SELECT * FROM COMPANY WHERE AGE &gt;= 35 OR SALARY &lt;= 22000; SELECT * FROM COMPANY WHERE NAME LIKE &#34;Ki%&#34;; SELECT * FROM COMPANY WHERE GLOB &#34;Ki*&#34;; SELECT * FROM COMPANY WHERE AGE IN (25,35); SELECT * FROM COMPANY WHERE AGE NOT IN (25,27); SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27; SELECT * FROM WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); #SELECT AND 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] AND [condition2] AND [conditon3]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; #SELECT OR 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] OR [condition2] OR [condition3]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; #更新标桩已有的数据 UPDATE table_name SET col1=val1, col2=val2, ... WHERE [condition]; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;,SALARY = 2000.00; #删除表中已有的记录 DELETE FROM tabel_name WHERE [condition]; DELETE FROM COMPANY WHERE ID = 1; DELETE FROM COMPANY; #删除全部数据 #限制select语句返回的数据数量 SELECT * FROM COMPANY LIMIT 6; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; #从第3个开始返回3个数据 #基于一列或多列进行排序 SELECT * FROM COMPANY ORDER BY SALARY ASC; SELECT * FROM COMPANY ORDER BY AGE DESC; SELECT * FROM COMPANY ORDER BY NAME,SALARY ASC; #对相同的数据进行分组 SELECT NAME,SUM(SALARY) FROM COMPANY GROUP BY NAME; SELECT NAME,SUM(SALARY) FROM COMAPNY GROUP BY NAME ORDER BY NAME; #指定条件过滤 SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &gt;2; SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &lt;2 ORDER BY NAME; #去重复 SELECT DISTINCT NAME FROM COMPANY; SQLITE PRAGMA PRAGMA [database.]auto_vacuum; PRAGMA [database.]auto_vacuum = mode; #mode 0 / NONE 默认模式，禁用auto_vacuum，数据库尺寸不会缩小，除非手动使用VACUUM命令 PRAGMA [database.]cache_size; PRAGMA [database.]cache_size = pages; #pages 表示在缓存中的页面数 PRAGMA case_sensitive_like = [true|false]; #控制like表达式的大小写敏感度 PRAGMA count_changes; PRAGMA count_changes = [true | false]; #pragma 获取或设置数据操作语句的返回值默认false不返回任何值 PRAGMA database_list; #列出所有的数据库连接 PRAGMA encoding; PRAGMA encoding = format; #格式可以是utf-8 utf-16 utf-16e之一 PRAGMA [database.]freelist_count; #当前被标记为免费和可用的数据库页面数 PRAGMA [database.]index_info(index_name); #返回关于数据库索引的信息 PRAGMA [database.]index_list(index_name); #列出所有与表相关的索引 PRAGMA journal_mode; PRAGMA journal_mode = mode; PRAGMA database.journal_mode; PRAGMA database.journal_mode = mode; #获取和设置控制日志文件如何存储和处理的日志模式 DELETE 默认模式，事物结束后，日志文件将被删除 TRUNCATE 日志文件被截断为0字节长度 PERSIST 日志文件被留在原地，但头部被重写，表明日志不再有效 MEMORY 日志记录保留在内存上，而不是磁盘上 OFF	不保留任何日志记录 PRAGMA [database.]max_page_count; PRAGMA [database.]max_page_count = max_page; #获取和设置数据库允许的最大页树; PRAGMA [database.]page_count; #获取和设置当前数据库的网页数量 PRAGMA [database.]page_size; PRAGMA [database.]page_size = bytes; #数据库页面大小 512 1024 2048 4096 8192 32768 PRAGMA parser_trace = [true | false]; #随着解析SQL命令来控制打印的调试状态 PRAGMA recursive_triggers; PRAGMA recursive_triggers = [true| false]; #递归触发器功能 PRAGMA [database.]schema_version = number; #获取或设置存储在数据库头中的架构版本信息 PRAGMA secure_delete; PRAGMA secure_delete = [true | false]; PRAGMA [database.]secure_delete = [true | false]; #控制内容是如何从数据库中删除的 默认关闭 PRAGMA sql_trace; PRAGMA sql_trace = [true | false]; #用于把sql 跟踪结果转储到屏幕上 PRAGMA [database.]synchronous; PRAGMA [database.]synchronous = mode; # 获取或设置当前磁盘的同步模式 0 OFF 不进行同步 1 NORMAL 在关键的磁盘操作的每个序列后同步 2 FULL 在每个关键的磁盘操作后同步 PRAGMA temp_store; PRAGMA temp_store = mode; #获取或设置临时数据库文件所使用的存储模式 0 DEFAULT 默认使用编译时的模式 FILE 1 FILE 使用基于文件的存储 2 MEMORY 使用基于内存的存储 PRAGMA temp_store_directory; PRAGMA temp_store_directory = &#34;dir_path&#34;; #获取或设置用于临时数据库文件的位置 PRAGMA [database.]user_version = number; #获取或设置存储在数据库头的用户自定义的版本，可以由开发人员设置，用于版本跟踪的目的 PRAGMA writable_schema; PRAGMA writable_schema = [true|false]; #获取或设置是否能够修改系统表 SQLITE 约束 //NOT NULL //默认情况下列是可以保存NULL，可以指定该列上不允许存在NULL值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADRRESS CHAR(50), SALARY REAL ); //DEFAULT //在没有提供一个特定的值的时候，提供一个默认值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //UNIQUE //防止在一个特定的列存在的两个记录具有相同的值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL UNIQUE, ADRRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //PRIMARY KEY //约束唯一标识数据库中的每个记录，一个只能有一个主键 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); //CHECK //启用输入一条记录要检查值的条件，如果条件值为false,则记录违反了约束，且不能输入到表中 CREATE TABLE company ( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL CHECK(SALARY &gt; 0) ); //删除约束 ALTER TABLE table_name DROP CONSTRAINT primary_key_name; ALTER TABLE table_name DROP CONSTRAINT unique_constraint_name; ALTER TABLE table_name DROP CONSTRAINT foreign_key_constraint_name; SQLITE JOIN //CROSS JOIN //把第一个表的每一行与第二个表的每一行进行匹配 SELECT emp_id,name,dept FROM company CROSS JOIN department; //INNER JOIN //根据连接谓词结合两个表的列值来创建一个新的结果表,为默认的连接类型 SELECT emp_id,name,dept FROM company INNER JOIN deparment ON company.id = department.emp_id; //OUTER JOIN //INNER JOIN后使用NULL填充 SELECT emp_id,name,dept FROM compamy OUTER JOIN department ON company.id = department.id; SQLITE TRIGGER CREATE TRIGGER trigger_name [BEFORE|AFTER] [UPDATE|INSERT|DELETE] ON table_name BEGIN ...trigger logic END; CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); CREATE TABLE audit( emp_id INT NOT NULL, entry_date TEXT NOT NULL ); CREATE TRIGGER audit_log AFTER INSERT ON company BEGIN INSERT INTO audit VALUES (new.ID,datatime(&#39;now&#39;)); END; //列出触发器 SELECT * FROM sqlite_master WHERE type=&#39;trigger&#39; AND tbl_name=&#39;company&#39;; DROP TRIGGER trigger_name;//删除触发器 索引 一种特殊的查找表，数据库引擎用来加快数据检索，索引是指向表中数据的指针。 能够加快select where语句的速度，但会减慢update insert语句的数据输入 #单列索引 CREATE INDEX index_name ON table_name (column_name); #唯一索引 CREATE UNIQUE index_name ON table_name (column_name); #组合索引 CREATE INDEX index_name ON table_name (col1,col2,...); //隐式索引，创建对象时数据库自动创建的索引 //删除索引 DROP INDEX index_name; CREATE INDEX salary_index ON company (salary); .indices company SELECT * FROM slqite_master WHERE type = &#39;index&#39;; DROP INDEX salary_index //使用索引查找 SELECT |DELETE | UPDATE col1,col2,... INDEXED BY (index_name) table_name WHERE (condition); SELECT * FROM company INDEXED BY salary_index WHERE salary &gt; 5000; SQLITE ALTER 用于修改表名字和添加列 ALTER TABLE database_name.table_name RENAME TO new_table_name; ALTER TABLE database_name.table_name ADD COLUMN column_def ...; SQLITE INCREMENT CREATE TABLE company( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INT NOT NULL, address CHAR(50), salary REAL );//AUTOINCREMENT 用于表中的字段值自动递增 SLQITE TRANSACTION BEGIN;COMMIT;ROLLBACK; //一个例子 BEGIN; DELETE FROM company WHERE age = 35; ROLLBACK; //取消删除 //一个例子 BEGIN; DELETE FROM company WHERE age = 34; COMMIT;//成功删除">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-20T22:00:24+08:00">
    <meta property="article:modified_time" content="2025-09-20T22:00:24+08:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Sqlite">
  <meta name="twitter:description" content="sqlite3 db sqlite3 命令 .help #获取可用命令的清单 .show #显示当前各种设置的值 .timeout MS #尝试打开锁定的表的时间 .timer on/off #开启或关闭cpu定时器 .width NUM NUM #为column 模式设置列宽度 .mode MODE # csv,column,html,line,list,tabs,tcl .stats on|off #开启或关闭统计 .header on/off #开启或关闭头部显示 .echo on/off #开启或关闭echo命令 .tables #列出表的名称 .databases #列出数据库的名称极其所依附的文件 .quit #退出sqlite提示符 .exit #退出sqlite提示符 .schema sqlite_master #主表中保存数据库的关键信息，并把它命名为sqlite_master SQLITE 数据类型 NULL //Null值 INTEGER	//有符号整数 REAL //浮点数 TEXT	//文本字符串 BLOB //blob数据，完全根据它的输入存储 SQLITE 亲和类型 TEXT 数值型在被插入前，需要先被转换为文本格式，再被插入到目标字段中 NUMERIC 当文本数据被插入到亲缘行为NUMERIC的字段中，如果转换操作不会导致数据信息丢失以及完全可逆，将该文本数据转换为INTEGER或REAL类型的数据。 如果转换失败，仍会以TEXT的方式存储。NULL BLOB不做任何转换，直接以NULL或BLOB的方式存储。 浮点数可以转换为整数类型而不会丢失数据信息，那么将以INTEGER的类型存储。 INTEGER 基本等同于NUMERIC REAL 数字以real存储，文本能转换则转换 NONE 不做任何转换 亲和类型及类型名称 亲和类型 数据类型 INTEGER INT INTEGERTINYINTSMALLINTMEDIUMINTBIGINTUNSIGNED BIG INTINT2 INT8 TEXT CHARACTER(20) VARCHAR(255)VARYING CHARACTER(255)NCHAR(55)NATIVE CHARACTER(70)&gt;NVARCHAR(100)TEXTCLOB BLOB BLOB 未指定 REAL REALDOUBLEDOUBLE PRECISIONFLOAT NUMERIC NUMERICDECIMAL(10,5)BOOLEANDATEDATETIME BOOLEAN sqlite 没有单独的boolean存储类型，整数0和1表示false和true DATRE &amp; TIME sqlite 没有单独的用于存储日期和时间的存储类型，能够把日期表示为TEXT REAL INTEGER类型 sqlite3 DatabaseName.db .open test.db .quit sqlite3 testDB.db .dump &gt; testDB.sql sqlite2 testDB.db &lt; testDB.sql ATTACH DATABASE &#39;TESTdb.DB&#39; AS &#34;TEST&#34;; .database DETACH DATABASE &#39;TEST&#39;; .databases #创建表 CREATE TABLE database_name.table_name ( col1 datatype PRIMARY KEY(one or more columns), col2 datatype, ... ); CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL, ); .tables #删除表 DROP TABLE database_name.table_name; .tables DROP TABLE COMPANY; #在表中新增数据 INSERT INTO table_name [(col1,col2,col3,...)] VALUES (val1,val2,val3,...); INSERT INTO table_name VALUES(val1,val2,...); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1,&#39;PAUL&#39;,32,&#39;California&#39;,20000.00); INSERT INTO COMPANY VALUES (2,&#39;Allen&#39;,23,&#34;Texas&#34;,29998.9); INSERT INTO COMPANY [(col1,col2,col3,...)] SELECT col1,col2,col3,... FROM COMPANY2 [WHERE condition]; #SELECT 查询语句 SELECT col1,col2,... FROM table_name; SELECT * FROM COMPANY; SELECT ID,NAME,SALARY FROM COMPANY; SELECT tbl_name FROM sqlite_master WHERE type = &#34;table&#34;; SELECT sql FROM sqlite_master WHERE type =&#34;table&#34; AND tbl_name = &#34;COMPANY&#34;; #sqlite 表达式 SELECT CURRENT_TIMESTAMP; //日期表达式 SELECT (15 &#43; 16) AS ADDITION; //数值表达式 SELECT * FROM COMPANY WHERE SALARY = 10000; //布尔表达式 #SELECT WHERE 语句 SELECT col1,col2,... FROM table_name WHERE [condition]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 6500; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; SELECT * FROM COMPANY WHERE AGE &gt;= 35 OR SALARY &lt;= 22000; SELECT * FROM COMPANY WHERE NAME LIKE &#34;Ki%&#34;; SELECT * FROM COMPANY WHERE GLOB &#34;Ki*&#34;; SELECT * FROM COMPANY WHERE AGE IN (25,35); SELECT * FROM COMPANY WHERE AGE NOT IN (25,27); SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27; SELECT * FROM WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); #SELECT AND 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] AND [condition2] AND [conditon3]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; #SELECT OR 运算符 SELECT col1,col2,... FROM table_name WHERE [condition1] OR [condition2] OR [condition3]; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; #更新标桩已有的数据 UPDATE table_name SET col1=val1, col2=val2, ... WHERE [condition]; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;,SALARY = 2000.00; #删除表中已有的记录 DELETE FROM tabel_name WHERE [condition]; DELETE FROM COMPANY WHERE ID = 1; DELETE FROM COMPANY; #删除全部数据 #限制select语句返回的数据数量 SELECT * FROM COMPANY LIMIT 6; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; #从第3个开始返回3个数据 #基于一列或多列进行排序 SELECT * FROM COMPANY ORDER BY SALARY ASC; SELECT * FROM COMPANY ORDER BY AGE DESC; SELECT * FROM COMPANY ORDER BY NAME,SALARY ASC; #对相同的数据进行分组 SELECT NAME,SUM(SALARY) FROM COMPANY GROUP BY NAME; SELECT NAME,SUM(SALARY) FROM COMAPNY GROUP BY NAME ORDER BY NAME; #指定条件过滤 SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &gt;2; SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &lt;2 ORDER BY NAME; #去重复 SELECT DISTINCT NAME FROM COMPANY; SQLITE PRAGMA PRAGMA [database.]auto_vacuum; PRAGMA [database.]auto_vacuum = mode; #mode 0 / NONE 默认模式，禁用auto_vacuum，数据库尺寸不会缩小，除非手动使用VACUUM命令 PRAGMA [database.]cache_size; PRAGMA [database.]cache_size = pages; #pages 表示在缓存中的页面数 PRAGMA case_sensitive_like = [true|false]; #控制like表达式的大小写敏感度 PRAGMA count_changes; PRAGMA count_changes = [true | false]; #pragma 获取或设置数据操作语句的返回值默认false不返回任何值 PRAGMA database_list; #列出所有的数据库连接 PRAGMA encoding; PRAGMA encoding = format; #格式可以是utf-8 utf-16 utf-16e之一 PRAGMA [database.]freelist_count; #当前被标记为免费和可用的数据库页面数 PRAGMA [database.]index_info(index_name); #返回关于数据库索引的信息 PRAGMA [database.]index_list(index_name); #列出所有与表相关的索引 PRAGMA journal_mode; PRAGMA journal_mode = mode; PRAGMA database.journal_mode; PRAGMA database.journal_mode = mode; #获取和设置控制日志文件如何存储和处理的日志模式 DELETE 默认模式，事物结束后，日志文件将被删除 TRUNCATE 日志文件被截断为0字节长度 PERSIST 日志文件被留在原地，但头部被重写，表明日志不再有效 MEMORY 日志记录保留在内存上，而不是磁盘上 OFF	不保留任何日志记录 PRAGMA [database.]max_page_count; PRAGMA [database.]max_page_count = max_page; #获取和设置数据库允许的最大页树; PRAGMA [database.]page_count; #获取和设置当前数据库的网页数量 PRAGMA [database.]page_size; PRAGMA [database.]page_size = bytes; #数据库页面大小 512 1024 2048 4096 8192 32768 PRAGMA parser_trace = [true | false]; #随着解析SQL命令来控制打印的调试状态 PRAGMA recursive_triggers; PRAGMA recursive_triggers = [true| false]; #递归触发器功能 PRAGMA [database.]schema_version = number; #获取或设置存储在数据库头中的架构版本信息 PRAGMA secure_delete; PRAGMA secure_delete = [true | false]; PRAGMA [database.]secure_delete = [true | false]; #控制内容是如何从数据库中删除的 默认关闭 PRAGMA sql_trace; PRAGMA sql_trace = [true | false]; #用于把sql 跟踪结果转储到屏幕上 PRAGMA [database.]synchronous; PRAGMA [database.]synchronous = mode; # 获取或设置当前磁盘的同步模式 0 OFF 不进行同步 1 NORMAL 在关键的磁盘操作的每个序列后同步 2 FULL 在每个关键的磁盘操作后同步 PRAGMA temp_store; PRAGMA temp_store = mode; #获取或设置临时数据库文件所使用的存储模式 0 DEFAULT 默认使用编译时的模式 FILE 1 FILE 使用基于文件的存储 2 MEMORY 使用基于内存的存储 PRAGMA temp_store_directory; PRAGMA temp_store_directory = &#34;dir_path&#34;; #获取或设置用于临时数据库文件的位置 PRAGMA [database.]user_version = number; #获取或设置存储在数据库头的用户自定义的版本，可以由开发人员设置，用于版本跟踪的目的 PRAGMA writable_schema; PRAGMA writable_schema = [true|false]; #获取或设置是否能够修改系统表 SQLITE 约束 //NOT NULL //默认情况下列是可以保存NULL，可以指定该列上不允许存在NULL值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADRRESS CHAR(50), SALARY REAL ); //DEFAULT //在没有提供一个特定的值的时候，提供一个默认值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //UNIQUE //防止在一个特定的列存在的两个记录具有相同的值 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL UNIQUE, ADRRESS CHAR(50), SALARY REAL DEFAULT 50000.00 ); //PRIMARY KEY //约束唯一标识数据库中的每个记录，一个只能有一个主键 CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); //CHECK //启用输入一条记录要检查值的条件，如果条件值为false,则记录违反了约束，且不能输入到表中 CREATE TABLE company ( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL CHECK(SALARY &gt; 0) ); //删除约束 ALTER TABLE table_name DROP CONSTRAINT primary_key_name; ALTER TABLE table_name DROP CONSTRAINT unique_constraint_name; ALTER TABLE table_name DROP CONSTRAINT foreign_key_constraint_name; SQLITE JOIN //CROSS JOIN //把第一个表的每一行与第二个表的每一行进行匹配 SELECT emp_id,name,dept FROM company CROSS JOIN department; //INNER JOIN //根据连接谓词结合两个表的列值来创建一个新的结果表,为默认的连接类型 SELECT emp_id,name,dept FROM company INNER JOIN deparment ON company.id = department.emp_id; //OUTER JOIN //INNER JOIN后使用NULL填充 SELECT emp_id,name,dept FROM compamy OUTER JOIN department ON company.id = department.id; SQLITE TRIGGER CREATE TRIGGER trigger_name [BEFORE|AFTER] [UPDATE|INSERT|DELETE] ON table_name BEGIN ...trigger logic END; CREATE TABLE company( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); CREATE TABLE audit( emp_id INT NOT NULL, entry_date TEXT NOT NULL ); CREATE TRIGGER audit_log AFTER INSERT ON company BEGIN INSERT INTO audit VALUES (new.ID,datatime(&#39;now&#39;)); END; //列出触发器 SELECT * FROM sqlite_master WHERE type=&#39;trigger&#39; AND tbl_name=&#39;company&#39;; DROP TRIGGER trigger_name;//删除触发器 索引 一种特殊的查找表，数据库引擎用来加快数据检索，索引是指向表中数据的指针。 能够加快select where语句的速度，但会减慢update insert语句的数据输入 #单列索引 CREATE INDEX index_name ON table_name (column_name); #唯一索引 CREATE UNIQUE index_name ON table_name (column_name); #组合索引 CREATE INDEX index_name ON table_name (col1,col2,...); //隐式索引，创建对象时数据库自动创建的索引 //删除索引 DROP INDEX index_name; CREATE INDEX salary_index ON company (salary); .indices company SELECT * FROM slqite_master WHERE type = &#39;index&#39;; DROP INDEX salary_index //使用索引查找 SELECT |DELETE | UPDATE col1,col2,... INDEXED BY (index_name) table_name WHERE (condition); SELECT * FROM company INDEXED BY salary_index WHERE salary &gt; 5000; SQLITE ALTER 用于修改表名字和添加列 ALTER TABLE database_name.table_name RENAME TO new_table_name; ALTER TABLE database_name.table_name ADD COLUMN column_def ...; SQLITE INCREMENT CREATE TABLE company( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INT NOT NULL, address CHAR(50), salary REAL );//AUTOINCREMENT 用于表中的字段值自动递增 SLQITE TRANSACTION BEGIN;COMMIT;ROLLBACK; //一个例子 BEGIN; DELETE FROM company WHERE age = 35; ROLLBACK; //取消删除 //一个例子 BEGIN; DELETE FROM company WHERE age = 34; COMMIT;//成功删除">

  <link rel="canonical" href="https://bjmu1026.github.io/blog/posts/sqlite/" />
</head>
<body
    class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"
  ><header
  class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"
>
  <div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto">
    <a
      class="-translate-y-[1px] text-2xl font-medium"
      href="https://bjmu1026.github.io/blog/"
      >TongXu-Server</a
    >
    <div
      class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8"
    role="button"
    aria-label="Menu"
  ></div>

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"
  >
  </div>
</header>
<main
      class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"
    ><article>
  <header class="mb-14">
    <h1 class="my-0! pb-2.5">Sqlite</h1><div class="text-xs antialiased opacity-60"><time>Sep 20, 2025</time></div></header>

  <section><h2 id="sqlite3-db">sqlite3 db</h2>
<ul>
<li>sqlite3 命令</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">.help #获取可用命令的清单
.show #显示当前各种设置的值
.timeout MS #尝试打开锁定的表的时间

.timer on/off #开启或关闭cpu定时器
.width NUM NUM  #为column 模式设置列宽度
.mode MODE # csv,column,html,line,list,tabs,tcl 
.stats on|off  #开启或关闭统计
.header on/off #开启或关闭头部显示
.echo on/off #开启或关闭echo命令

.tables #列出表的名称
.databases #列出数据库的名称极其所依附的文件
.quit #退出sqlite提示符
.exit #退出sqlite提示符

.schema sqlite_master #主表中保存数据库的关键信息，并把它命名为sqlite_master
</code></pre><ul>
<li>SQLITE 数据类型
<ul>
<li>NULL  		//Null值</li>
<li>INTEGER	   //有符号整数</li>
<li>REAL                 //浮点数</li>
<li>TEXT		 //文本字符串</li>
<li>BLOB               //blob数据，完全根据它的输入存储</li>
</ul>
</li>
<li>SQLITE 亲和类型
<ul>
<li>TEXT 数值型在被插入前，需要先被转换为文本格式，再被插入到目标字段中</li>
<li>NUMERIC 当文本数据被插入到亲缘行为NUMERIC的字段中，如果转换操作不会导致数据信息丢失以及完全可逆，将该文本数据转换为INTEGER或REAL类型的数据。 如果转换失败，仍会以TEXT的方式存储。NULL BLOB不做任何转换，直接以NULL或BLOB的方式存储。 浮点数可以转换为整数类型而不会丢失数据信息，那么将以INTEGER的类型存储。</li>
<li>INTEGER  基本等同于NUMERIC</li>
<li>REAL     数字以real存储，文本能转换则转换</li>
<li>NONE  不做任何转换</li>
</ul>
</li>
<li>亲和类型及类型名称</li>
</ul>
<table>
  <thead>
      <tr>
          <th>亲和类型</th>
          <th>数据类型</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>INTEGER</td>
          <td>INT <!-- raw HTML omitted -->INTEGER<!-- raw HTML omitted -->TINYINT<!-- raw HTML omitted -->SMALLINT<!-- raw HTML omitted -->MEDIUMINT<!-- raw HTML omitted -->BIGINT<!-- raw HTML omitted -->UNSIGNED  BIG INT<!-- raw HTML omitted -->INT2 <!-- raw HTML omitted -->INT8</td>
      </tr>
      <tr>
          <td>TEXT</td>
          <td>CHARACTER(20) <!-- raw HTML omitted -->VARCHAR(255)<!-- raw HTML omitted -->VARYING CHARACTER(255)<!-- raw HTML omitted -->NCHAR(55)<!-- raw HTML omitted -->NATIVE CHARACTER(70)&gt;<!-- raw HTML omitted -->NVARCHAR(100)<!-- raw HTML omitted -->TEXT<!-- raw HTML omitted -->CLOB</td>
      </tr>
      <tr>
          <td>BLOB</td>
          <td>BLOB <!-- raw HTML omitted -->未指定</td>
      </tr>
      <tr>
          <td>REAL</td>
          <td>REAL<!-- raw HTML omitted -->DOUBLE<!-- raw HTML omitted -->DOUBLE PRECISION<!-- raw HTML omitted -->FLOAT</td>
      </tr>
      <tr>
          <td>NUMERIC</td>
          <td>NUMERIC<!-- raw HTML omitted -->DECIMAL(10,5)<!-- raw HTML omitted -->BOOLEAN<!-- raw HTML omitted -->DATE<!-- raw HTML omitted -->DATETIME<!-- raw HTML omitted --></td>
      </tr>
  </tbody>
</table>
<ul>
<li>BOOLEAN
<ul>
<li>sqlite 没有单独的boolean存储类型，整数0和1表示false和true</li>
</ul>
</li>
<li>DATRE &amp; TIME
<ul>
<li>sqlite 没有单独的用于存储日期和时间的存储类型，能够把日期表示为TEXT REAL INTEGER类型</li>
</ul>
</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">sqlite3 DatabaseName.db
.open test.db
.quit

sqlite3 testDB.db .dump &gt; testDB.sql
sqlite2 testDB.db &lt; testDB.sql

ATTACH DATABASE &#39;TESTdb.DB&#39; AS &#34;TEST&#34;;
.database
DETACH DATABASE &#39;TEST&#39;;
.databases
</code></pre><pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">#创建表
CREATE TABLE database_name.table_name (
	col1 datatype PRIMARY KEY(one or more columns),
    col2 datatype,
    ...
);
CREATE TABLE COMPANY(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL,
);
.tables

#删除表
DROP TABLE database_name.table_name;
.tables
DROP TABLE COMPANY;

#在表中新增数据
INSERT INTO table_name [(col1,col2,col3,...)] VALUES (val1,val2,val3,...);
INSERT INTO table_name VALUES(val1,val2,...);
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1,&#39;PAUL&#39;,32,&#39;California&#39;,20000.00);
INSERT INTO COMPANY VALUES (2,&#39;Allen&#39;,23,&#34;Texas&#34;,29998.9);
INSERT INTO COMPANY [(col1,col2,col3,...)] SELECT col1,col2,col3,... FROM COMPANY2 [WHERE condition];

#SELECT 查询语句
SELECT col1,col2,... FROM table_name;
SELECT * FROM COMPANY;
SELECT ID,NAME,SALARY FROM COMPANY;
SELECT tbl_name FROM  sqlite_master WHERE type = &#34;table&#34;;
SELECT sql FROM sqlite_master WHERE type =&#34;table&#34; AND tbl_name = &#34;COMPANY&#34;;

#sqlite 表达式
SELECT CURRENT_TIMESTAMP; //日期表达式
SELECT (15 + 16) AS ADDITION; //数值表达式
SELECT * FROM COMPANY WHERE SALARY = 10000; //布尔表达式

#SELECT WHERE 语句
SELECT col1,col2,... FROM table_name WHERE [condition];
SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 6500;
SELECT * FROM COMPANY WHERE AGE IS NOT NULL;
SELECT * FROM COMPANY WHERE AGE &gt;= 35 OR SALARY &lt;= 22000;
SELECT * FROM COMPANY WHERE NAME LIKE &#34;Ki%&#34;;
SELECT * FROM COMPANY WHERE GLOB &#34;Ki*&#34;;
SELECT * FROM COMPANY WHERE AGE IN (25,35);
SELECT * FROM COMPANY WHERE AGE NOT IN (25,27);
SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;
SELECT * FROM WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);
SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);

#SELECT AND 运算符
SELECT col1,col2,... FROM table_name WHERE [condition1] AND [condition2] AND [conditon3];
SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;
#SELECT OR 运算符
SELECT col1,col2,... FROM table_name WHERE [condition1] OR [condition2] OR [condition3];
SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;

#更新标桩已有的数据
UPDATE table_name SET col1=val1, col2=val2, ... WHERE [condition];
UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6;
UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;,SALARY = 2000.00;

#删除表中已有的记录
DELETE FROM tabel_name WHERE [condition];
DELETE FROM COMPANY WHERE ID = 1;
DELETE FROM COMPANY; #删除全部数据

#限制select语句返回的数据数量
SELECT * FROM COMPANY LIMIT 6;
SELECT * FROM COMPANY LIMIT 3 OFFSET 2;  #从第3个开始返回3个数据

#基于一列或多列进行排序
SELECT * FROM COMPANY ORDER BY SALARY ASC;
SELECT * FROM COMPANY ORDER BY AGE DESC;
SELECT * FROM COMPANY ORDER BY NAME,SALARY ASC;

#对相同的数据进行分组
SELECT NAME,SUM(SALARY) FROM COMPANY GROUP BY NAME;
SELECT NAME,SUM(SALARY) FROM COMAPNY GROUP BY NAME ORDER BY NAME;

#指定条件过滤
SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &gt;2;
SELECT * FROM COMPANY GROUP BY NAME HAVING COUNT(NAME) &lt;2 ORDER BY NAME;

#去重复
SELECT DISTINCT NAME FROM COMPANY;
</code></pre><ul>
<li>SQLITE PRAGMA</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">PRAGMA [database.]auto_vacuum;
PRAGMA [database.]auto_vacuum = mode;
#mode 0 / NONE  默认模式，禁用auto_vacuum，数据库尺寸不会缩小，除非手动使用VACUUM命令

PRAGMA [database.]cache_size;
PRAGMA [database.]cache_size = pages;
#pages 表示在缓存中的页面数

PRAGMA case_sensitive_like = [true|false];
#控制like表达式的大小写敏感度

PRAGMA count_changes;
PRAGMA count_changes = [true | false];
#pragma 获取或设置数据操作语句的返回值默认false不返回任何值

PRAGMA database_list;
#列出所有的数据库连接

PRAGMA encoding;
PRAGMA encoding = format;
#格式可以是utf-8 utf-16 utf-16e之一

PRAGMA [database.]freelist_count;
#当前被标记为免费和可用的数据库页面数

PRAGMA [database.]index_info(index_name);
#返回关于数据库索引的信息

PRAGMA [database.]index_list(index_name);
#列出所有与表相关的索引

PRAGMA journal_mode;
PRAGMA journal_mode = mode;
PRAGMA database.journal_mode;
PRAGMA database.journal_mode = mode;
#获取和设置控制日志文件如何存储和处理的日志模式
DELETE 默认模式，事物结束后，日志文件将被删除
TRUNCATE 日志文件被截断为0字节长度
PERSIST 日志文件被留在原地，但头部被重写，表明日志不再有效
MEMORY 日志记录保留在内存上，而不是磁盘上
OFF		不保留任何日志记录

PRAGMA [database.]max_page_count;
PRAGMA [database.]max_page_count = max_page;
#获取和设置数据库允许的最大页树;

PRAGMA [database.]page_count;
#获取和设置当前数据库的网页数量

PRAGMA [database.]page_size;
PRAGMA [database.]page_size = bytes;
#数据库页面大小  512 1024 2048 4096 8192 32768

PRAGMA parser_trace = [true | false];
#随着解析SQL命令来控制打印的调试状态

PRAGMA recursive_triggers;
PRAGMA recursive_triggers = [true| false];
#递归触发器功能

PRAGMA [database.]schema_version = number;
#获取或设置存储在数据库头中的架构版本信息

PRAGMA secure_delete;
PRAGMA secure_delete = [true | false];
PRAGMA [database.]secure_delete = [true | false];
#控制内容是如何从数据库中删除的 默认关闭

PRAGMA sql_trace;
PRAGMA sql_trace = [true | false];
#用于把sql 跟踪结果转储到屏幕上

PRAGMA [database.]synchronous;
PRAGMA [database.]synchronous = mode;
# 获取或设置当前磁盘的同步模式
0 OFF 不进行同步
1 NORMAL 在关键的磁盘操作的每个序列后同步
2 FULL 在每个关键的磁盘操作后同步

PRAGMA temp_store;
PRAGMA temp_store = mode;
#获取或设置临时数据库文件所使用的存储模式
0 DEFAULT 默认使用编译时的模式 FILE
1 FILE    使用基于文件的存储
2 MEMORY  使用基于内存的存储

PRAGMA temp_store_directory;
PRAGMA temp_store_directory = &#34;dir_path&#34;;
#获取或设置用于临时数据库文件的位置

PRAGMA [database.]user_version = number;
#获取或设置存储在数据库头的用户自定义的版本，可以由开发人员设置，用于版本跟踪的目的

PRAGMA writable_schema;
PRAGMA writable_schema = [true|false];
#获取或设置是否能够修改系统表
</code></pre><ul>
<li>SQLITE 约束</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">//NOT NULL
//默认情况下列是可以保存NULL，可以指定该列上不允许存在NULL值
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL, 
    ADRRESS CHAR(50),
    SALARY REAL
);
//DEFAULT
//在没有提供一个特定的值的时候，提供一个默认值
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL DEFAULT 50000.00
);
//UNIQUE
//防止在一个特定的列存在的两个记录具有相同的值
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL UNIQUE,
    ADRRESS CHAR(50),
    SALARY REAL DEFAULT 50000.00
);
//PRIMARY KEY
//约束唯一标识数据库中的每个记录，一个只能有一个主键
CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL
);
//CHECK
//启用输入一条记录要检查值的条件，如果条件值为false,则记录违反了约束，且不能输入到表中
CREATE TABLE company (
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL CHECK(SALARY &gt; 0)
);
//删除约束
ALTER TABLE table_name DROP CONSTRAINT primary_key_name;
ALTER TABLE table_name DROP CONSTRAINT unique_constraint_name;
ALTER TABLE table_name DROP  CONSTRAINT foreign_key_constraint_name;
</code></pre><ul>
<li>SQLITE JOIN</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">//CROSS JOIN 
//把第一个表的每一行与第二个表的每一行进行匹配
SELECT emp_id,name,dept FROM company CROSS JOIN department;

//INNER JOIN
//根据连接谓词结合两个表的列值来创建一个新的结果表,为默认的连接类型
SELECT emp_id,name,dept FROM company INNER JOIN deparment ON company.id = department.emp_id;

//OUTER JOIN
//INNER JOIN后使用NULL填充
SELECT emp_id,name,dept FROM  compamy OUTER JOIN department ON company.id = department.id;
</code></pre><ul>
<li>SQLITE TRIGGER</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">CREATE TRIGGER trigger_name [BEFORE|AFTER] [UPDATE|INSERT|DELETE]
ON table_name
BEGIN
	...trigger logic 
END;


CREATE TABLE company(
	ID INT PRIMARY KEY NOT NULL,
    NAME TEXT NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(50),
    SALARY REAL
);

CREATE TABLE audit(
	emp_id INT NOT NULL,
    entry_date TEXT NOT NULL
);

CREATE TRIGGER audit_log AFTER INSERT ON company
BEGIN
	INSERT INTO audit VALUES (new.ID,datatime(&#39;now&#39;));
END;

//列出触发器
SELECT * FROM sqlite_master WHERE type=&#39;trigger&#39; AND tbl_name=&#39;company&#39;;
DROP TRIGGER trigger_name;//删除触发器
</code></pre><ul>
<li>索引</li>
<li>一种特殊的查找表，数据库引擎用来加快数据检索，索引是指向表中数据的指针。</li>
<li>能够加快select  where语句的速度，但会减慢update insert语句的数据输入</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">#单列索引
CREATE INDEX index_name ON table_name (column_name);
#唯一索引
CREATE UNIQUE index_name ON table_name (column_name);
#组合索引
CREATE INDEX index_name ON table_name (col1,col2,...);

//隐式索引，创建对象时数据库自动创建的索引

//删除索引
DROP INDEX index_name;


CREATE INDEX salary_index ON company (salary);
.indices company
SELECT * FROM slqite_master WHERE type = &#39;index&#39;;
DROP INDEX salary_index


//使用索引查找
SELECT |DELETE | UPDATE col1,col2,...
INDEXED BY (index_name)
table_name
WHERE (condition);

SELECT * FROM company INDEXED BY salary_index WHERE salary &gt; 5000;
</code></pre><ul>
<li>SQLITE ALTER</li>
<li>用于修改表名字和添加列</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">ALTER TABLE database_name.table_name RENAME TO new_table_name;
ALTER TABLE database_name.table_name ADD COLUMN column_def ...;
</code></pre><ul>
<li>SQLITE INCREMENT</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">CREATE TABLE company(
	id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INT NOT NULL,
    address CHAR(50),
    salary REAL
);//AUTOINCREMENT 用于表中的字段值自动递增
</code></pre><ul>
<li>SLQITE TRANSACTION</li>
</ul>
<pre tabindex="0"><code class="language-sqlite" data-lang="sqlite">BEGIN;COMMIT;ROLLBACK;

//一个例子
BEGIN;
DELETE FROM company WHERE age = 35;
ROLLBACK; //取消删除

//一个例子
BEGIN;
DELETE FROM company WHERE age = 34;
COMMIT;//成功删除
</code></pre></section>

  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  ><a
      class="justify-end pl-3 ltr:ml-auto rtl:mr-auto"
      href="https://bjmu1026.github.io/blog/posts/grub-btrfs/"
      ><span>Grub Btrfs</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    ></nav></article></main><footer
  class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"
>
  <div class="mr-auto">&copy;2025<a class="link" href="https://bjmu1026.github.io/blog/">TongXu-Server</a></div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >powered by hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >hugo-paper</a
  >
</footer>
</body>
</html>
